// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod model {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_NODE_TYPE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_NODE_TYPE: u32 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NODE_TYPE: [NodeType; 3] = [
  NodeType::Default,
  NodeType::Chained,
  NodeType::Floating,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NodeType(pub u32);
#[allow(non_upper_case_globals)]
impl NodeType {
  pub const Default: Self = Self(0);
  pub const Chained: Self = Self(1);
  pub const Floating: Self = Self(2);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Chained,
    Self::Floating,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Chained => Some("Chained"),
      Self::Floating => Some("Floating"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for NodeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for NodeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for NodeType {
    type Output = NodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NodeType {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for NodeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for NodeType {}
// struct Vec3, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec3(pub [u8; 12]);
impl Default for Vec3 { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Vec3 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vec3")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
impl<'a> flatbuffers::Follow<'a> for Vec3 {
  type Inner = &'a Vec3;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec3>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
  type Inner = &'a Vec3;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec3 {
    type Output = Vec3;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec3 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vec3 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
    z: f32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> Vec3T {
    Vec3T {
      x: self.x(),
      y: self.y(),
      z: self.z(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3T {
  pub x: f32,
  pub y: f32,
  pub z: f32,
}
impl Vec3T {
  pub fn pack(&self) -> Vec3 {
    Vec3::new(
      self.x,
      self.y,
      self.z,
    )
  }
}

// struct Vec4, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec4(pub [u8; 16]);
impl Default for Vec4 { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Vec4 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vec4")
      .field("w", &self.w())
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec4 {}
impl<'a> flatbuffers::Follow<'a> for Vec4 {
  type Inner = &'a Vec4;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec4>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec4 {
  type Inner = &'a Vec4;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec4>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec4 {
    type Output = Vec4;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec4 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec4 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vec4 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    w: f32,
    x: f32,
    y: f32,
    z: f32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_w(w);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn w(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_w(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> Vec4T {
    Vec4T {
      w: self.w(),
      x: self.x(),
      y: self.y(),
      z: self.z(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec4T {
  pub w: f32,
  pub x: f32,
  pub y: f32,
  pub z: f32,
}
impl Vec4T {
  pub fn pack(&self) -> Vec4 {
    Vec4::new(
      self.w,
      self.x,
      self.y,
      self.z,
    )
  }
}

pub enum TransformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Transform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transform<'a> {
  type Inner = Transform<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Transform<'a> {
  pub const VT_VECSCALE: flatbuffers::VOffsetT = 4;
  pub const VT_VECROT: flatbuffers::VOffsetT = 6;
  pub const VT_VECTRANSLATE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Transform { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TransformArgs<'args>
  ) -> flatbuffers::WIPOffset<Transform<'bldr>> {
    let mut builder = TransformBuilder::new(_fbb);
    if let Some(x) = args.VecTranslate { builder.add_VecTranslate(x); }
    if let Some(x) = args.VecRot { builder.add_VecRot(x); }
    if let Some(x) = args.VecScale { builder.add_VecScale(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TransformT {
    let VecScale = self.VecScale().map(|x| {
      x.unpack()
    });
    let VecRot = self.VecRot().map(|x| {
      x.unpack()
    });
    let VecTranslate = self.VecTranslate().map(|x| {
      x.unpack()
    });
    TransformT {
      VecScale,
      VecRot,
      VecTranslate,
    }
  }

  #[inline]
  pub fn VecScale(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(Transform::VT_VECSCALE, None)}
  }
  #[inline]
  pub fn VecRot(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(Transform::VT_VECROT, None)}
  }
  #[inline]
  pub fn VecTranslate(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(Transform::VT_VECTRANSLATE, None)}
  }
}

impl flatbuffers::Verifiable for Transform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3>("VecScale", Self::VT_VECSCALE, false)?
     .visit_field::<Vec3>("VecRot", Self::VT_VECROT, false)?
     .visit_field::<Vec3>("VecTranslate", Self::VT_VECTRANSLATE, false)?
     .finish();
    Ok(())
  }
}
pub struct TransformArgs<'a> {
    pub VecScale: Option<&'a Vec3>,
    pub VecRot: Option<&'a Vec3>,
    pub VecTranslate: Option<&'a Vec3>,
}
impl<'a> Default for TransformArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransformArgs {
      VecScale: None,
      VecRot: None,
      VecTranslate: None,
    }
  }
}

pub struct TransformBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransformBuilder<'a, 'b> {
  #[inline]
  pub fn add_VecScale(&mut self, VecScale: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(Transform::VT_VECSCALE, VecScale);
  }
  #[inline]
  pub fn add_VecRot(&mut self, VecRot: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(Transform::VT_VECROT, VecRot);
  }
  #[inline]
  pub fn add_VecTranslate(&mut self, VecTranslate: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(Transform::VT_VECTRANSLATE, VecTranslate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransformBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Transform<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Transform");
      ds.field("VecScale", &self.VecScale());
      ds.field("VecRot", &self.VecRot());
      ds.field("VecTranslate", &self.VecTranslate());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TransformT {
  pub VecScale: Option<Vec3T>,
  pub VecRot: Option<Vec3T>,
  pub VecTranslate: Option<Vec3T>,
}
impl Default for TransformT {
  fn default() -> Self {
    Self {
      VecScale: None,
      VecRot: None,
      VecTranslate: None,
    }
  }
}
impl TransformT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Transform<'b>> {
    let VecScale_tmp = self.VecScale.as_ref().map(|x| x.pack());
    let VecScale = VecScale_tmp.as_ref();
    let VecRot_tmp = self.VecRot.as_ref().map(|x| x.pack());
    let VecRot = VecRot_tmp.as_ref();
    let VecTranslate_tmp = self.VecTranslate.as_ref().map(|x| x.pack());
    let VecTranslate = VecTranslate_tmp.as_ref();
    Transform::create(_fbb, &TransformArgs{
      VecScale,
      VecRot,
      VecTranslate,
    })
  }
}
pub enum TransformNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransformNode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformNode<'a> {
  type Inner = TransformNode<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransformNode<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSFORM: flatbuffers::VOffsetT = 6;
  pub const VT_SCALEPIVOT: flatbuffers::VOffsetT = 8;
  pub const VT_ROTATEPIVOT: flatbuffers::VOffsetT = 10;
  pub const VT_PARENT_IDX: flatbuffers::VOffsetT = 12;
  pub const VT_RIG_IDX: flatbuffers::VOffsetT = 14;
  pub const VT_EFFECT_NODE: flatbuffers::VOffsetT = 16;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransformNode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TransformNodeArgs<'args>
  ) -> flatbuffers::WIPOffset<TransformNode<'bldr>> {
    let mut builder = TransformNodeBuilder::new(_fbb);
    builder.add_type_(args.type_);
    if let Some(x) = args.effect_node { builder.add_effect_node(x); }
    builder.add_rig_idx(args.rig_idx);
    builder.add_parent_idx(args.parent_idx);
    if let Some(x) = args.rotatePivot { builder.add_rotatePivot(x); }
    if let Some(x) = args.scalePivot { builder.add_scalePivot(x); }
    if let Some(x) = args.transform { builder.add_transform(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TransformNodeT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let transform = self.transform().map(|x| {
      Box::new(x.unpack())
    });
    let scalePivot = self.scalePivot().map(|x| {
      x.unpack()
    });
    let rotatePivot = self.rotatePivot().map(|x| {
      x.unpack()
    });
    let parent_idx = self.parent_idx();
    let rig_idx = self.rig_idx();
    let effect_node = self.effect_node().map(|x| {
      x.to_string()
    });
    let type_ = self.type_();
    TransformNodeT {
      name,
      transform,
      scalePivot,
      rotatePivot,
      parent_idx,
      rig_idx,
      effect_node,
      type_,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransformNode::VT_NAME, None)}
  }
  #[inline]
  pub fn transform(&self) -> Option<Transform<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Transform>>(TransformNode::VT_TRANSFORM, None)}
  }
  #[inline]
  pub fn scalePivot(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(TransformNode::VT_SCALEPIVOT, None)}
  }
  #[inline]
  pub fn rotatePivot(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(TransformNode::VT_ROTATEPIVOT, None)}
  }
  #[inline]
  pub fn parent_idx(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TransformNode::VT_PARENT_IDX, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn rig_idx(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TransformNode::VT_RIG_IDX, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn effect_node(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransformNode::VT_EFFECT_NODE, None)}
  }
  #[inline]
  pub fn type_(&self) -> NodeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<NodeType>(TransformNode::VT_TYPE_, Some(NodeType::Default)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TransformNode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Transform>>("transform", Self::VT_TRANSFORM, false)?
     .visit_field::<Vec3>("scalePivot", Self::VT_SCALEPIVOT, false)?
     .visit_field::<Vec3>("rotatePivot", Self::VT_ROTATEPIVOT, false)?
     .visit_field::<i32>("parent_idx", Self::VT_PARENT_IDX, false)?
     .visit_field::<i32>("rig_idx", Self::VT_RIG_IDX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effect_node", Self::VT_EFFECT_NODE, false)?
     .visit_field::<NodeType>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct TransformNodeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transform: Option<flatbuffers::WIPOffset<Transform<'a>>>,
    pub scalePivot: Option<&'a Vec3>,
    pub rotatePivot: Option<&'a Vec3>,
    pub parent_idx: i32,
    pub rig_idx: i32,
    pub effect_node: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: NodeType,
}
impl<'a> Default for TransformNodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransformNodeArgs {
      name: None,
      transform: None,
      scalePivot: None,
      rotatePivot: None,
      parent_idx: -1,
      rig_idx: -1,
      effect_node: None,
      type_: NodeType::Default,
    }
  }
}

pub struct TransformNodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransformNodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformNode::VT_NAME, name);
  }
  #[inline]
  pub fn add_transform(&mut self, transform: flatbuffers::WIPOffset<Transform<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transform>>(TransformNode::VT_TRANSFORM, transform);
  }
  #[inline]
  pub fn add_scalePivot(&mut self, scalePivot: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(TransformNode::VT_SCALEPIVOT, scalePivot);
  }
  #[inline]
  pub fn add_rotatePivot(&mut self, rotatePivot: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(TransformNode::VT_ROTATEPIVOT, rotatePivot);
  }
  #[inline]
  pub fn add_parent_idx(&mut self, parent_idx: i32) {
    self.fbb_.push_slot::<i32>(TransformNode::VT_PARENT_IDX, parent_idx, -1);
  }
  #[inline]
  pub fn add_rig_idx(&mut self, rig_idx: i32) {
    self.fbb_.push_slot::<i32>(TransformNode::VT_RIG_IDX, rig_idx, -1);
  }
  #[inline]
  pub fn add_effect_node(&mut self, effect_node: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformNode::VT_EFFECT_NODE, effect_node);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: NodeType) {
    self.fbb_.push_slot::<NodeType>(TransformNode::VT_TYPE_, type_, NodeType::Default);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransformNodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransformNodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransformNode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransformNode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransformNode");
      ds.field("name", &self.name());
      ds.field("transform", &self.transform());
      ds.field("scalePivot", &self.scalePivot());
      ds.field("rotatePivot", &self.rotatePivot());
      ds.field("parent_idx", &self.parent_idx());
      ds.field("rig_idx", &self.rig_idx());
      ds.field("effect_node", &self.effect_node());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TransformNodeT {
  pub name: Option<String>,
  pub transform: Option<Box<TransformT>>,
  pub scalePivot: Option<Vec3T>,
  pub rotatePivot: Option<Vec3T>,
  pub parent_idx: i32,
  pub rig_idx: i32,
  pub effect_node: Option<String>,
  pub type_: NodeType,
}
impl Default for TransformNodeT {
  fn default() -> Self {
    Self {
      name: None,
      transform: None,
      scalePivot: None,
      rotatePivot: None,
      parent_idx: -1,
      rig_idx: -1,
      effect_node: None,
      type_: NodeType::Default,
    }
  }
}
impl TransformNodeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TransformNode<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transform = self.transform.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let scalePivot_tmp = self.scalePivot.as_ref().map(|x| x.pack());
    let scalePivot = scalePivot_tmp.as_ref();
    let rotatePivot_tmp = self.rotatePivot.as_ref().map(|x| x.pack());
    let rotatePivot = rotatePivot_tmp.as_ref();
    let parent_idx = self.parent_idx;
    let rig_idx = self.rig_idx;
    let effect_node = self.effect_node.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_;
    TransformNode::create(_fbb, &TransformNodeArgs{
      name,
      transform,
      scalePivot,
      rotatePivot,
      parent_idx,
      rig_idx,
      effect_node,
      type_,
    })
  }
}
pub enum IKControlOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IKControl<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IKControl<'a> {
  type Inner = IKControl<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IKControl<'a> {
  pub const VT_IK_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_IK_CHAIN_START: flatbuffers::VOffsetT = 6;
  pub const VT_IK_CHAIN_END: flatbuffers::VOffsetT = 8;
  pub const VT_IK_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_RES_4: flatbuffers::VOffsetT = 12;
  pub const VT_IK_POS: flatbuffers::VOffsetT = 14;
  pub const VT_IK_ROT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IKControl { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IKControlArgs<'args>
  ) -> flatbuffers::WIPOffset<IKControl<'bldr>> {
    let mut builder = IKControlBuilder::new(_fbb);
    if let Some(x) = args.ik_rot { builder.add_ik_rot(x); }
    if let Some(x) = args.ik_pos { builder.add_ik_pos(x); }
    builder.add_res_4(args.res_4);
    if let Some(x) = args.ik_type { builder.add_ik_type(x); }
    if let Some(x) = args.ik_chain_end { builder.add_ik_chain_end(x); }
    if let Some(x) = args.ik_chain_start { builder.add_ik_chain_start(x); }
    if let Some(x) = args.ik_name { builder.add_ik_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> IKControlT {
    let ik_name = self.ik_name().map(|x| {
      x.to_string()
    });
    let ik_chain_start = self.ik_chain_start().map(|x| {
      x.to_string()
    });
    let ik_chain_end = self.ik_chain_end().map(|x| {
      x.to_string()
    });
    let ik_type = self.ik_type().map(|x| {
      x.to_string()
    });
    let res_4 = self.res_4();
    let ik_pos = self.ik_pos().map(|x| {
      x.unpack()
    });
    let ik_rot = self.ik_rot().map(|x| {
      x.unpack()
    });
    IKControlT {
      ik_name,
      ik_chain_start,
      ik_chain_end,
      ik_type,
      res_4,
      ik_pos,
      ik_rot,
    }
  }

  #[inline]
  pub fn ik_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IKControl::VT_IK_NAME, None)}
  }
  #[inline]
  pub fn ik_chain_start(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IKControl::VT_IK_CHAIN_START, None)}
  }
  #[inline]
  pub fn ik_chain_end(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IKControl::VT_IK_CHAIN_END, None)}
  }
  #[inline]
  pub fn ik_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IKControl::VT_IK_TYPE, None)}
  }
  #[inline]
  pub fn res_4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(IKControl::VT_RES_4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ik_pos(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(IKControl::VT_IK_POS, None)}
  }
  #[inline]
  pub fn ik_rot(&self) -> Option<&'a Vec4> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec4>(IKControl::VT_IK_ROT, None)}
  }
}

impl flatbuffers::Verifiable for IKControl<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ik_name", Self::VT_IK_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ik_chain_start", Self::VT_IK_CHAIN_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ik_chain_end", Self::VT_IK_CHAIN_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ik_type", Self::VT_IK_TYPE, false)?
     .visit_field::<u32>("res_4", Self::VT_RES_4, false)?
     .visit_field::<Vec3>("ik_pos", Self::VT_IK_POS, false)?
     .visit_field::<Vec4>("ik_rot", Self::VT_IK_ROT, false)?
     .finish();
    Ok(())
  }
}
pub struct IKControlArgs<'a> {
    pub ik_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ik_chain_start: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ik_chain_end: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ik_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub res_4: u32,
    pub ik_pos: Option<&'a Vec3>,
    pub ik_rot: Option<&'a Vec4>,
}
impl<'a> Default for IKControlArgs<'a> {
  #[inline]
  fn default() -> Self {
    IKControlArgs {
      ik_name: None,
      ik_chain_start: None,
      ik_chain_end: None,
      ik_type: None,
      res_4: 0,
      ik_pos: None,
      ik_rot: None,
    }
  }
}

pub struct IKControlBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IKControlBuilder<'a, 'b> {
  #[inline]
  pub fn add_ik_name(&mut self, ik_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IKControl::VT_IK_NAME, ik_name);
  }
  #[inline]
  pub fn add_ik_chain_start(&mut self, ik_chain_start: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IKControl::VT_IK_CHAIN_START, ik_chain_start);
  }
  #[inline]
  pub fn add_ik_chain_end(&mut self, ik_chain_end: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IKControl::VT_IK_CHAIN_END, ik_chain_end);
  }
  #[inline]
  pub fn add_ik_type(&mut self, ik_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IKControl::VT_IK_TYPE, ik_type);
  }
  #[inline]
  pub fn add_res_4(&mut self, res_4: u32) {
    self.fbb_.push_slot::<u32>(IKControl::VT_RES_4, res_4, 0);
  }
  #[inline]
  pub fn add_ik_pos(&mut self, ik_pos: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(IKControl::VT_IK_POS, ik_pos);
  }
  #[inline]
  pub fn add_ik_rot(&mut self, ik_rot: &Vec4) {
    self.fbb_.push_slot_always::<&Vec4>(IKControl::VT_IK_ROT, ik_rot);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IKControlBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IKControlBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IKControl<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IKControl<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IKControl");
      ds.field("ik_name", &self.ik_name());
      ds.field("ik_chain_start", &self.ik_chain_start());
      ds.field("ik_chain_end", &self.ik_chain_end());
      ds.field("ik_type", &self.ik_type());
      ds.field("res_4", &self.res_4());
      ds.field("ik_pos", &self.ik_pos());
      ds.field("ik_rot", &self.ik_rot());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IKControlT {
  pub ik_name: Option<String>,
  pub ik_chain_start: Option<String>,
  pub ik_chain_end: Option<String>,
  pub ik_type: Option<String>,
  pub res_4: u32,
  pub ik_pos: Option<Vec3T>,
  pub ik_rot: Option<Vec4T>,
}
impl Default for IKControlT {
  fn default() -> Self {
    Self {
      ik_name: None,
      ik_chain_start: None,
      ik_chain_end: None,
      ik_type: None,
      res_4: 0,
      ik_pos: None,
      ik_rot: None,
    }
  }
}
impl IKControlT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<IKControl<'b>> {
    let ik_name = self.ik_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ik_chain_start = self.ik_chain_start.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ik_chain_end = self.ik_chain_end.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ik_type = self.ik_type.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let res_4 = self.res_4;
    let ik_pos_tmp = self.ik_pos.as_ref().map(|x| x.pack());
    let ik_pos = ik_pos_tmp.as_ref();
    let ik_rot_tmp = self.ik_rot.as_ref().map(|x| x.pack());
    let ik_rot = ik_rot_tmp.as_ref();
    IKControl::create(_fbb, &IKControlArgs{
      ik_name,
      ik_chain_start,
      ik_chain_end,
      ik_type,
      res_4,
      ik_pos,
      ik_rot,
    })
  }
}
pub enum BoneMatrixOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoneMatrix<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoneMatrix<'a> {
  type Inner = BoneMatrix<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoneMatrix<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_Z: flatbuffers::VOffsetT = 8;
  pub const VT_W: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoneMatrix { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoneMatrixArgs<'args>
  ) -> flatbuffers::WIPOffset<BoneMatrix<'bldr>> {
    let mut builder = BoneMatrixBuilder::new(_fbb);
    if let Some(x) = args.w { builder.add_w(x); }
    if let Some(x) = args.z { builder.add_z(x); }
    if let Some(x) = args.y { builder.add_y(x); }
    if let Some(x) = args.x { builder.add_x(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BoneMatrixT {
    let x = self.x().map(|x| {
      x.unpack()
    });
    let y = self.y().map(|x| {
      x.unpack()
    });
    let z = self.z().map(|x| {
      x.unpack()
    });
    let w = self.w().map(|x| {
      x.unpack()
    });
    BoneMatrixT {
      x,
      y,
      z,
      w,
    }
  }

  #[inline]
  pub fn x(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(BoneMatrix::VT_X, None)}
  }
  #[inline]
  pub fn y(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(BoneMatrix::VT_Y, None)}
  }
  #[inline]
  pub fn z(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(BoneMatrix::VT_Z, None)}
  }
  #[inline]
  pub fn w(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(BoneMatrix::VT_W, None)}
  }
}

impl flatbuffers::Verifiable for BoneMatrix<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3>("x", Self::VT_X, false)?
     .visit_field::<Vec3>("y", Self::VT_Y, false)?
     .visit_field::<Vec3>("z", Self::VT_Z, false)?
     .visit_field::<Vec3>("w", Self::VT_W, false)?
     .finish();
    Ok(())
  }
}
pub struct BoneMatrixArgs<'a> {
    pub x: Option<&'a Vec3>,
    pub y: Option<&'a Vec3>,
    pub z: Option<&'a Vec3>,
    pub w: Option<&'a Vec3>,
}
impl<'a> Default for BoneMatrixArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoneMatrixArgs {
      x: None,
      y: None,
      z: None,
      w: None,
    }
  }
}

pub struct BoneMatrixBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoneMatrixBuilder<'a, 'b> {
  #[inline]
  pub fn add_x(&mut self, x: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(BoneMatrix::VT_X, x);
  }
  #[inline]
  pub fn add_y(&mut self, y: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(BoneMatrix::VT_Y, y);
  }
  #[inline]
  pub fn add_z(&mut self, z: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(BoneMatrix::VT_Z, z);
  }
  #[inline]
  pub fn add_w(&mut self, w: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(BoneMatrix::VT_W, w);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoneMatrixBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoneMatrixBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoneMatrix<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoneMatrix<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoneMatrix");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.field("w", &self.w());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BoneMatrixT {
  pub x: Option<Vec3T>,
  pub y: Option<Vec3T>,
  pub z: Option<Vec3T>,
  pub w: Option<Vec3T>,
}
impl Default for BoneMatrixT {
  fn default() -> Self {
    Self {
      x: None,
      y: None,
      z: None,
      w: None,
    }
  }
}
impl BoneMatrixT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<BoneMatrix<'b>> {
    let x_tmp = self.x.as_ref().map(|x| x.pack());
    let x = x_tmp.as_ref();
    let y_tmp = self.y.as_ref().map(|x| x.pack());
    let y = y_tmp.as_ref();
    let z_tmp = self.z.as_ref().map(|x| x.pack());
    let z = z_tmp.as_ref();
    let w_tmp = self.w.as_ref().map(|x| x.pack());
    let w = w_tmp.as_ref();
    BoneMatrix::create(_fbb, &BoneMatrixArgs{
      x,
      y,
      z,
      w,
    })
  }
}
pub enum BoneOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bone<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bone<'a> {
  type Inner = Bone<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Bone<'a> {
  pub const VT_INHERIT_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_UNK_BOOL_2: flatbuffers::VOffsetT = 6;
  pub const VT_MATRIX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Bone { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoneArgs<'args>
  ) -> flatbuffers::WIPOffset<Bone<'bldr>> {
    let mut builder = BoneBuilder::new(_fbb);
    if let Some(x) = args.matrix { builder.add_matrix(x); }
    builder.add_unk_bool_2(args.unk_bool_2);
    builder.add_inherit_position(args.inherit_position);
    builder.finish()
  }

  pub fn unpack(&self) -> BoneT {
    let inherit_position = self.inherit_position();
    let unk_bool_2 = self.unk_bool_2();
    let matrix = self.matrix().map(|x| {
      Box::new(x.unpack())
    });
    BoneT {
      inherit_position,
      unk_bool_2,
      matrix,
    }
  }

  #[inline]
  pub fn inherit_position(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Bone::VT_INHERIT_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk_bool_2(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Bone::VT_UNK_BOOL_2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn matrix(&self) -> Option<BoneMatrix<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BoneMatrix>>(Bone::VT_MATRIX, None)}
  }
}

impl flatbuffers::Verifiable for Bone<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("inherit_position", Self::VT_INHERIT_POSITION, false)?
     .visit_field::<u8>("unk_bool_2", Self::VT_UNK_BOOL_2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BoneMatrix>>("matrix", Self::VT_MATRIX, false)?
     .finish();
    Ok(())
  }
}
pub struct BoneArgs<'a> {
    pub inherit_position: u8,
    pub unk_bool_2: u8,
    pub matrix: Option<flatbuffers::WIPOffset<BoneMatrix<'a>>>,
}
impl<'a> Default for BoneArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoneArgs {
      inherit_position: 0,
      unk_bool_2: 0,
      matrix: None,
    }
  }
}

pub struct BoneBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoneBuilder<'a, 'b> {
  #[inline]
  pub fn add_inherit_position(&mut self, inherit_position: u8) {
    self.fbb_.push_slot::<u8>(Bone::VT_INHERIT_POSITION, inherit_position, 0);
  }
  #[inline]
  pub fn add_unk_bool_2(&mut self, unk_bool_2: u8) {
    self.fbb_.push_slot::<u8>(Bone::VT_UNK_BOOL_2, unk_bool_2, 0);
  }
  #[inline]
  pub fn add_matrix(&mut self, matrix: flatbuffers::WIPOffset<BoneMatrix<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BoneMatrix>>(Bone::VT_MATRIX, matrix);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoneBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoneBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bone<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Bone<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Bone");
      ds.field("inherit_position", &self.inherit_position());
      ds.field("unk_bool_2", &self.unk_bool_2());
      ds.field("matrix", &self.matrix());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BoneT {
  pub inherit_position: u8,
  pub unk_bool_2: u8,
  pub matrix: Option<Box<BoneMatrixT>>,
}
impl Default for BoneT {
  fn default() -> Self {
    Self {
      inherit_position: 0,
      unk_bool_2: 0,
      matrix: None,
    }
  }
}
impl BoneT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Bone<'b>> {
    let inherit_position = self.inherit_position;
    let unk_bool_2 = self.unk_bool_2;
    let matrix = self.matrix.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Bone::create(_fbb, &BoneArgs{
      inherit_position,
      unk_bool_2,
      matrix,
    })
  }
}
pub enum TRSKLOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TRSKL<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TRSKL<'a> {
  type Inner = TRSKL<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TRSKL<'a> {
  pub const VT_RES_0: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSFORM_NODES: flatbuffers::VOffsetT = 6;
  pub const VT_BONES: flatbuffers::VOffsetT = 8;
  pub const VT_IKS: flatbuffers::VOffsetT = 10;
  pub const VT_RIG_OFFSET: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TRSKL { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TRSKLArgs<'args>
  ) -> flatbuffers::WIPOffset<TRSKL<'bldr>> {
    let mut builder = TRSKLBuilder::new(_fbb);
    builder.add_rig_offset(args.rig_offset);
    if let Some(x) = args.iks { builder.add_iks(x); }
    if let Some(x) = args.bones { builder.add_bones(x); }
    if let Some(x) = args.transform_nodes { builder.add_transform_nodes(x); }
    builder.add_res_0(args.res_0);
    builder.finish()
  }

  pub fn unpack(&self) -> TRSKLT {
    let res_0 = self.res_0();
    let transform_nodes = self.transform_nodes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let bones = self.bones().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let iks = self.iks().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let rig_offset = self.rig_offset();
    TRSKLT {
      res_0,
      transform_nodes,
      bones,
      iks,
      rig_offset,
    }
  }

  #[inline]
  pub fn res_0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TRSKL::VT_RES_0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn transform_nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformNode<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformNode>>>>(TRSKL::VT_TRANSFORM_NODES, None)}
  }
  #[inline]
  pub fn bones(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bone<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bone>>>>(TRSKL::VT_BONES, None)}
  }
  #[inline]
  pub fn iks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IKControl<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IKControl>>>>(TRSKL::VT_IKS, None)}
  }
  #[inline]
  pub fn rig_offset(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TRSKL::VT_RIG_OFFSET, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TRSKL<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("res_0", Self::VT_RES_0, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransformNode>>>>("transform_nodes", Self::VT_TRANSFORM_NODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Bone>>>>("bones", Self::VT_BONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IKControl>>>>("iks", Self::VT_IKS, false)?
     .visit_field::<u32>("rig_offset", Self::VT_RIG_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct TRSKLArgs<'a> {
    pub res_0: u32,
    pub transform_nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformNode<'a>>>>>,
    pub bones: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bone<'a>>>>>,
    pub iks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IKControl<'a>>>>>,
    pub rig_offset: u32,
}
impl<'a> Default for TRSKLArgs<'a> {
  #[inline]
  fn default() -> Self {
    TRSKLArgs {
      res_0: 0,
      transform_nodes: None,
      bones: None,
      iks: None,
      rig_offset: 0,
    }
  }
}

pub struct TRSKLBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TRSKLBuilder<'a, 'b> {
  #[inline]
  pub fn add_res_0(&mut self, res_0: u32) {
    self.fbb_.push_slot::<u32>(TRSKL::VT_RES_0, res_0, 0);
  }
  #[inline]
  pub fn add_transform_nodes(&mut self, transform_nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TransformNode<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRSKL::VT_TRANSFORM_NODES, transform_nodes);
  }
  #[inline]
  pub fn add_bones(&mut self, bones: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bone<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRSKL::VT_BONES, bones);
  }
  #[inline]
  pub fn add_iks(&mut self, iks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IKControl<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRSKL::VT_IKS, iks);
  }
  #[inline]
  pub fn add_rig_offset(&mut self, rig_offset: u32) {
    self.fbb_.push_slot::<u32>(TRSKL::VT_RIG_OFFSET, rig_offset, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRSKLBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TRSKLBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TRSKL<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TRSKL<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TRSKL");
      ds.field("res_0", &self.res_0());
      ds.field("transform_nodes", &self.transform_nodes());
      ds.field("bones", &self.bones());
      ds.field("iks", &self.iks());
      ds.field("rig_offset", &self.rig_offset());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TRSKLT {
  pub res_0: u32,
  pub transform_nodes: Option<Vec<TransformNodeT>>,
  pub bones: Option<Vec<BoneT>>,
  pub iks: Option<Vec<IKControlT>>,
  pub rig_offset: u32,
}
impl Default for TRSKLT {
  fn default() -> Self {
    Self {
      res_0: 0,
      transform_nodes: None,
      bones: None,
      iks: None,
      rig_offset: 0,
    }
  }
}
impl TRSKLT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TRSKL<'b>> {
    let res_0 = self.res_0;
    let transform_nodes = self.transform_nodes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let bones = self.bones.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let iks = self.iks.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let rig_offset = self.rig_offset;
    TRSKL::create(_fbb, &TRSKLArgs{
      res_0,
      transform_nodes,
      bones,
      iks,
      rig_offset,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TRSKL`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trskl_unchecked`.
pub fn root_as_trskl(buf: &[u8]) -> Result<TRSKL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TRSKL>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TRSKL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_trskl_unchecked`.
pub fn size_prefixed_root_as_trskl(buf: &[u8]) -> Result<TRSKL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TRSKL>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TRSKL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trskl_unchecked`.
pub fn root_as_trskl_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRSKL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TRSKL<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TRSKL` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trskl_unchecked`.
pub fn size_prefixed_root_as_trskl_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRSKL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TRSKL<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TRSKL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TRSKL`.
pub unsafe fn root_as_trskl_unchecked(buf: &[u8]) -> TRSKL {
  flatbuffers::root_unchecked::<TRSKL>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TRSKL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TRSKL`.
pub unsafe fn size_prefixed_root_as_trskl_unchecked(buf: &[u8]) -> TRSKL {
  flatbuffers::size_prefixed_root_unchecked::<TRSKL>(buf)
}
pub const TRSKL_EXTENSION: &str = "trskl";

#[inline]
pub fn finish_trskl_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<TRSKL<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_trskl_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<TRSKL<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Model
}  // pub mod Titan

