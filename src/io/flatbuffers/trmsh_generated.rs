// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod model {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VERTEX_ATTRIBUTE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VERTEX_ATTRIBUTE: u32 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VERTEX_ATTRIBUTE: [VertexAttribute; 11] = [
  VertexAttribute::NONE,
  VertexAttribute::POSITION,
  VertexAttribute::NORMAL,
  VertexAttribute::TANGENT,
  VertexAttribute::BINORMAL,
  VertexAttribute::COLOR,
  VertexAttribute::TEX_COORD,
  VertexAttribute::BLEND_INDICES,
  VertexAttribute::BLEND_WEIGHTS,
  VertexAttribute::USER,
  VertexAttribute::USER_ID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VertexAttribute(pub u32);
#[allow(non_upper_case_globals)]
impl VertexAttribute {
  pub const NONE: Self = Self(0);
  pub const POSITION: Self = Self(1);
  pub const NORMAL: Self = Self(2);
  pub const TANGENT: Self = Self(3);
  pub const BINORMAL: Self = Self(4);
  pub const COLOR: Self = Self(5);
  pub const TEX_COORD: Self = Self(6);
  pub const BLEND_INDICES: Self = Self(7);
  pub const BLEND_WEIGHTS: Self = Self(8);
  pub const USER: Self = Self(9);
  pub const USER_ID: Self = Self(10);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::POSITION,
    Self::NORMAL,
    Self::TANGENT,
    Self::BINORMAL,
    Self::COLOR,
    Self::TEX_COORD,
    Self::BLEND_INDICES,
    Self::BLEND_WEIGHTS,
    Self::USER,
    Self::USER_ID,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::POSITION => Some("POSITION"),
      Self::NORMAL => Some("NORMAL"),
      Self::TANGENT => Some("TANGENT"),
      Self::BINORMAL => Some("BINORMAL"),
      Self::COLOR => Some("COLOR"),
      Self::TEX_COORD => Some("TEX_COORD"),
      Self::BLEND_INDICES => Some("BLEND_INDICES"),
      Self::BLEND_WEIGHTS => Some("BLEND_WEIGHTS"),
      Self::USER => Some("USER"),
      Self::USER_ID => Some("USER_ID"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VertexAttribute {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VertexAttribute {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VertexAttribute {
    type Output = VertexAttribute;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VertexAttribute {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VertexAttribute {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VertexAttribute {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MORPH_ATTRIBUTE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MORPH_ATTRIBUTE: u32 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MORPH_ATTRIBUTE: [MorphAttribute; 5] = [
  MorphAttribute::NONE,
  MorphAttribute::POSITION,
  MorphAttribute::MIN_LIMIT,
  MorphAttribute::MAX_LIMIT,
  MorphAttribute::USER_ID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MorphAttribute(pub u32);
#[allow(non_upper_case_globals)]
impl MorphAttribute {
  pub const NONE: Self = Self(0);
  pub const POSITION: Self = Self(1);
  pub const MIN_LIMIT: Self = Self(2);
  pub const MAX_LIMIT: Self = Self(3);
  pub const USER_ID: Self = Self(10);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::POSITION,
    Self::MIN_LIMIT,
    Self::MAX_LIMIT,
    Self::USER_ID,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::POSITION => Some("POSITION"),
      Self::MIN_LIMIT => Some("MIN_LIMIT"),
      Self::MAX_LIMIT => Some("MAX_LIMIT"),
      Self::USER_ID => Some("USER_ID"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MorphAttribute {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MorphAttribute {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MorphAttribute {
    type Output = MorphAttribute;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MorphAttribute {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MorphAttribute {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MorphAttribute {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TYPE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TYPE: u32 = 54;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TYPE: [Type; 10] = [
  Type::NONE,
  Type::R8_G8_B8_A8_UNSIGNED_NORMALIZED,
  Type::W8_X8_Y8_Z8_UNSIGNED,
  Type::X32_UINT,
  Type::X32_INT,
  Type::W16_X16_Y16_Z16_SIGNED_NORMALIZED,
  Type::W16_X16_Y16_Z16_FLOAT,
  Type::X32_Y32_FLOAT,
  Type::X32_Y32_Z32_FLOAT,
  Type::W32_X32_Y32_Z32_FLOAT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Type(pub u32);
#[allow(non_upper_case_globals)]
impl Type {
  pub const NONE: Self = Self(0);
  pub const R8_G8_B8_A8_UNSIGNED_NORMALIZED: Self = Self(20);
  pub const W8_X8_Y8_Z8_UNSIGNED: Self = Self(22);
  pub const X32_UINT: Self = Self(36);
  pub const X32_INT: Self = Self(37);
  pub const W16_X16_Y16_Z16_SIGNED_NORMALIZED: Self = Self(39);
  pub const W16_X16_Y16_Z16_FLOAT: Self = Self(43);
  pub const X32_Y32_FLOAT: Self = Self(48);
  pub const X32_Y32_Z32_FLOAT: Self = Self(51);
  pub const W32_X32_Y32_Z32_FLOAT: Self = Self(54);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 54;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::R8_G8_B8_A8_UNSIGNED_NORMALIZED,
    Self::W8_X8_Y8_Z8_UNSIGNED,
    Self::X32_UINT,
    Self::X32_INT,
    Self::W16_X16_Y16_Z16_SIGNED_NORMALIZED,
    Self::W16_X16_Y16_Z16_FLOAT,
    Self::X32_Y32_FLOAT,
    Self::X32_Y32_Z32_FLOAT,
    Self::W32_X32_Y32_Z32_FLOAT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::R8_G8_B8_A8_UNSIGNED_NORMALIZED => Some("R8_G8_B8_A8_UNSIGNED_NORMALIZED"),
      Self::W8_X8_Y8_Z8_UNSIGNED => Some("W8_X8_Y8_Z8_UNSIGNED"),
      Self::X32_UINT => Some("X32_UINT"),
      Self::X32_INT => Some("X32_INT"),
      Self::W16_X16_Y16_Z16_SIGNED_NORMALIZED => Some("W16_X16_Y16_Z16_SIGNED_NORMALIZED"),
      Self::W16_X16_Y16_Z16_FLOAT => Some("W16_X16_Y16_Z16_FLOAT"),
      Self::X32_Y32_FLOAT => Some("X32_Y32_FLOAT"),
      Self::X32_Y32_Z32_FLOAT => Some("X32_Y32_Z32_FLOAT"),
      Self::W32_X32_Y32_Z32_FLOAT => Some("W32_X32_Y32_Z32_FLOAT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Type {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Type {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Type {
    type Output = Type;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Type {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Type {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Type {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_POLYGON_TYPE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_POLYGON_TYPE: u32 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_POLYGON_TYPE: [PolygonType; 4] = [
  PolygonType::X8_Y8_Z8_UNSIGNED,
  PolygonType::X16_Y16_Z16_UNSIGNED,
  PolygonType::X32_Y32_Z32_UNSIGNED,
  PolygonType::X64_Y64_Z64_UNSIGNED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PolygonType(pub u32);
#[allow(non_upper_case_globals)]
impl PolygonType {
  pub const X8_Y8_Z8_UNSIGNED: Self = Self(0);
  pub const X16_Y16_Z16_UNSIGNED: Self = Self(1);
  pub const X32_Y32_Z32_UNSIGNED: Self = Self(2);
  pub const X64_Y64_Z64_UNSIGNED: Self = Self(3);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::X8_Y8_Z8_UNSIGNED,
    Self::X16_Y16_Z16_UNSIGNED,
    Self::X32_Y32_Z32_UNSIGNED,
    Self::X64_Y64_Z64_UNSIGNED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::X8_Y8_Z8_UNSIGNED => Some("X8_Y8_Z8_UNSIGNED"),
      Self::X16_Y16_Z16_UNSIGNED => Some("X16_Y16_Z16_UNSIGNED"),
      Self::X32_Y32_Z32_UNSIGNED => Some("X32_Y32_Z32_UNSIGNED"),
      Self::X64_Y64_Z64_UNSIGNED => Some("X64_Y64_Z64_UNSIGNED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PolygonType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PolygonType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PolygonType {
    type Output = PolygonType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PolygonType {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PolygonType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PolygonType {}
// struct Sphere, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Sphere(pub [u8; 16]);
impl Default for Sphere { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Sphere {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Sphere")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .field("radius", &self.radius())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Sphere {}
impl<'a> flatbuffers::Follow<'a> for Sphere {
  type Inner = &'a Sphere;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Sphere>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Sphere {
  type Inner = &'a Sphere;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Sphere>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Sphere {
    type Output = Sphere;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Sphere as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Sphere {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Sphere {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
    z: f32,
    radius: f32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s.set_radius(radius);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn radius(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_radius(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> SphereT {
    SphereT {
      x: self.x(),
      y: self.y(),
      z: self.z(),
      radius: self.radius(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct SphereT {
  pub x: f32,
  pub y: f32,
  pub z: f32,
  pub radius: f32,
}
impl SphereT {
  pub fn pack(&self) -> Sphere {
    Sphere::new(
      self.x,
      self.y,
      self.z,
      self.radius,
    )
  }
}

// struct Vec4, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec4(pub [u8; 16]);
impl Default for Vec4 { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Vec4 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vec4")
      .field("w", &self.w())
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec4 {}
impl<'a> flatbuffers::Follow<'a> for Vec4 {
  type Inner = &'a Vec4;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec4>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec4 {
  type Inner = &'a Vec4;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec4>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec4 {
    type Output = Vec4;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec4 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec4 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vec4 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    w: f32,
    x: f32,
    y: f32,
    z: f32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_w(w);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn w(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_w(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> Vec4T {
    Vec4T {
      w: self.w(),
      x: self.x(),
      y: self.y(),
      z: self.z(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec4T {
  pub w: f32,
  pub x: f32,
  pub y: f32,
  pub z: f32,
}
impl Vec4T {
  pub fn pack(&self) -> Vec4 {
    Vec4::new(
      self.w,
      self.x,
      self.y,
      self.z,
    )
  }
}

// struct Vec3, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec3(pub [u8; 12]);
impl Default for Vec3 { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Vec3 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vec3")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
impl<'a> flatbuffers::Follow<'a> for Vec3 {
  type Inner = &'a Vec3;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec3>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
  type Inner = &'a Vec3;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec3 {
    type Output = Vec3;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec3 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vec3 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
    z: f32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> Vec3T {
    Vec3T {
      x: self.x(),
      y: self.y(),
      z: self.z(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3T {
  pub x: f32,
  pub y: f32,
  pub z: f32,
}
impl Vec3T {
  pub fn pack(&self) -> Vec3 {
    Vec3::new(
      self.x,
      self.y,
      self.z,
    )
  }
}

pub enum BoundingBoxOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoundingBox<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoundingBox<'a> {
  type Inner = BoundingBox<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoundingBox<'a> {
  pub const VT_MIN: flatbuffers::VOffsetT = 4;
  pub const VT_MAX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoundingBox { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoundingBoxArgs<'args>
  ) -> flatbuffers::WIPOffset<BoundingBox<'bldr>> {
    let mut builder = BoundingBoxBuilder::new(_fbb);
    if let Some(x) = args.max { builder.add_max(x); }
    if let Some(x) = args.min { builder.add_min(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BoundingBoxT {
    let min = self.min().map(|x| {
      x.unpack()
    });
    let max = self.max().map(|x| {
      x.unpack()
    });
    BoundingBoxT {
      min,
      max,
    }
  }

  #[inline]
  pub fn min(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(BoundingBox::VT_MIN, None)}
  }
  #[inline]
  pub fn max(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(BoundingBox::VT_MAX, None)}
  }
}

impl flatbuffers::Verifiable for BoundingBox<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3>("min", Self::VT_MIN, false)?
     .visit_field::<Vec3>("max", Self::VT_MAX, false)?
     .finish();
    Ok(())
  }
}
pub struct BoundingBoxArgs<'a> {
    pub min: Option<&'a Vec3>,
    pub max: Option<&'a Vec3>,
}
impl<'a> Default for BoundingBoxArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoundingBoxArgs {
      min: None,
      max: None,
    }
  }
}

pub struct BoundingBoxBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoundingBoxBuilder<'a, 'b> {
  #[inline]
  pub fn add_min(&mut self, min: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(BoundingBox::VT_MIN, min);
  }
  #[inline]
  pub fn add_max(&mut self, max: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(BoundingBox::VT_MAX, max);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoundingBoxBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoundingBoxBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoundingBox<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoundingBox<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoundingBox");
      ds.field("min", &self.min());
      ds.field("max", &self.max());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BoundingBoxT {
  pub min: Option<Vec3T>,
  pub max: Option<Vec3T>,
}
impl Default for BoundingBoxT {
  fn default() -> Self {
    Self {
      min: None,
      max: None,
    }
  }
}
impl BoundingBoxT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<BoundingBox<'b>> {
    let min_tmp = self.min.as_ref().map(|x| x.pack());
    let min = min_tmp.as_ref();
    let max_tmp = self.max.as_ref().map(|x| x.pack());
    let max = max_tmp.as_ref();
    BoundingBox::create(_fbb, &BoundingBoxArgs{
      min,
      max,
    })
  }
}
pub enum InfluenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Influence<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Influence<'a> {
  type Inner = Influence<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Influence<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_SCALE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Influence { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InfluenceArgs
  ) -> flatbuffers::WIPOffset<Influence<'bldr>> {
    let mut builder = InfluenceBuilder::new(_fbb);
    builder.add_scale(args.scale);
    builder.add_index(args.index);
    builder.finish()
  }

  pub fn unpack(&self) -> InfluenceT {
    let index = self.index();
    let scale = self.scale();
    InfluenceT {
      index,
      scale,
    }
  }

  #[inline]
  pub fn index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Influence::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Influence::VT_SCALE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Influence<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("index", Self::VT_INDEX, false)?
     .visit_field::<f32>("scale", Self::VT_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct InfluenceArgs {
    pub index: u32,
    pub scale: f32,
}
impl<'a> Default for InfluenceArgs {
  #[inline]
  fn default() -> Self {
    InfluenceArgs {
      index: 0,
      scale: 0.0,
    }
  }
}

pub struct InfluenceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InfluenceBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(Influence::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: f32) {
    self.fbb_.push_slot::<f32>(Influence::VT_SCALE, scale, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfluenceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InfluenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Influence<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Influence<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Influence");
      ds.field("index", &self.index());
      ds.field("scale", &self.scale());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct InfluenceT {
  pub index: u32,
  pub scale: f32,
}
impl Default for InfluenceT {
  fn default() -> Self {
    Self {
      index: 0,
      scale: 0.0,
    }
  }
}
impl InfluenceT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Influence<'b>> {
    let index = self.index;
    let scale = self.scale;
    Influence::create(_fbb, &InfluenceArgs{
      index,
      scale,
    })
  }
}
pub enum VertexAccessorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VertexAccessor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VertexAccessor<'a> {
  type Inner = VertexAccessor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VertexAccessor<'a> {
  pub const VT_ATTR_0: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 6;
  pub const VT_ATTRIBUTE_LAYER: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_POSITION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VertexAccessor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VertexAccessorArgs
  ) -> flatbuffers::WIPOffset<VertexAccessor<'bldr>> {
    let mut builder = VertexAccessorBuilder::new(_fbb);
    builder.add_position(args.position);
    builder.add_type_(args.type_);
    builder.add_attribute_layer(args.attribute_layer);
    builder.add_attribute(args.attribute);
    builder.add_attr_0(args.attr_0);
    builder.finish()
  }

  pub fn unpack(&self) -> VertexAccessorT {
    let attr_0 = self.attr_0();
    let attribute = self.attribute();
    let attribute_layer = self.attribute_layer();
    let type_ = self.type_();
    let position = self.position();
    VertexAccessorT {
      attr_0,
      attribute,
      attribute_layer,
      type_,
      position,
    }
  }

  #[inline]
  pub fn attr_0(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(VertexAccessor::VT_ATTR_0, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn attribute(&self) -> VertexAttribute {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VertexAttribute>(VertexAccessor::VT_ATTRIBUTE, Some(VertexAttribute::NONE)).unwrap()}
  }
  #[inline]
  pub fn attribute_layer(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VertexAccessor::VT_ATTRIBUTE_LAYER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> Type {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Type>(VertexAccessor::VT_TYPE_, Some(Type::NONE)).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VertexAccessor::VT_POSITION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VertexAccessor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("attr_0", Self::VT_ATTR_0, false)?
     .visit_field::<VertexAttribute>("attribute", Self::VT_ATTRIBUTE, false)?
     .visit_field::<u32>("attribute_layer", Self::VT_ATTRIBUTE_LAYER, false)?
     .visit_field::<Type>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u32>("position", Self::VT_POSITION, false)?
     .finish();
    Ok(())
  }
}
pub struct VertexAccessorArgs {
    pub attr_0: i32,
    pub attribute: VertexAttribute,
    pub attribute_layer: u32,
    pub type_: Type,
    pub position: u32,
}
impl<'a> Default for VertexAccessorArgs {
  #[inline]
  fn default() -> Self {
    VertexAccessorArgs {
      attr_0: -1,
      attribute: VertexAttribute::NONE,
      attribute_layer: 0,
      type_: Type::NONE,
      position: 0,
    }
  }
}

pub struct VertexAccessorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VertexAccessorBuilder<'a, 'b> {
  #[inline]
  pub fn add_attr_0(&mut self, attr_0: i32) {
    self.fbb_.push_slot::<i32>(VertexAccessor::VT_ATTR_0, attr_0, -1);
  }
  #[inline]
  pub fn add_attribute(&mut self, attribute: VertexAttribute) {
    self.fbb_.push_slot::<VertexAttribute>(VertexAccessor::VT_ATTRIBUTE, attribute, VertexAttribute::NONE);
  }
  #[inline]
  pub fn add_attribute_layer(&mut self, attribute_layer: u32) {
    self.fbb_.push_slot::<u32>(VertexAccessor::VT_ATTRIBUTE_LAYER, attribute_layer, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: Type) {
    self.fbb_.push_slot::<Type>(VertexAccessor::VT_TYPE_, type_, Type::NONE);
  }
  #[inline]
  pub fn add_position(&mut self, position: u32) {
    self.fbb_.push_slot::<u32>(VertexAccessor::VT_POSITION, position, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VertexAccessorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VertexAccessorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VertexAccessor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VertexAccessor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VertexAccessor");
      ds.field("attr_0", &self.attr_0());
      ds.field("attribute", &self.attribute());
      ds.field("attribute_layer", &self.attribute_layer());
      ds.field("type_", &self.type_());
      ds.field("position", &self.position());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VertexAccessorT {
  pub attr_0: i32,
  pub attribute: VertexAttribute,
  pub attribute_layer: u32,
  pub type_: Type,
  pub position: u32,
}
impl Default for VertexAccessorT {
  fn default() -> Self {
    Self {
      attr_0: -1,
      attribute: VertexAttribute::NONE,
      attribute_layer: 0,
      type_: Type::NONE,
      position: 0,
    }
  }
}
impl VertexAccessorT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<VertexAccessor<'b>> {
    let attr_0 = self.attr_0;
    let attribute = self.attribute;
    let attribute_layer = self.attribute_layer;
    let type_ = self.type_;
    let position = self.position;
    VertexAccessor::create(_fbb, &VertexAccessorArgs{
      attr_0,
      attribute,
      attribute_layer,
      type_,
      position,
    })
  }
}
pub enum VertexSizeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VertexSize<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VertexSize<'a> {
  type Inner = VertexSize<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VertexSize<'a> {
  pub const VT_SIZE_: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VertexSize { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VertexSizeArgs
  ) -> flatbuffers::WIPOffset<VertexSize<'bldr>> {
    let mut builder = VertexSizeBuilder::new(_fbb);
    builder.add_size_(args.size_);
    builder.finish()
  }

  pub fn unpack(&self) -> VertexSizeT {
    let size_ = self.size_();
    VertexSizeT {
      size_,
    }
  }

  #[inline]
  pub fn size_(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VertexSize::VT_SIZE_, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VertexSize<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("size_", Self::VT_SIZE_, false)?
     .finish();
    Ok(())
  }
}
pub struct VertexSizeArgs {
    pub size_: u32,
}
impl<'a> Default for VertexSizeArgs {
  #[inline]
  fn default() -> Self {
    VertexSizeArgs {
      size_: 0,
    }
  }
}

pub struct VertexSizeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VertexSizeBuilder<'a, 'b> {
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(VertexSize::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VertexSizeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VertexSizeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VertexSize<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VertexSize<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VertexSize");
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VertexSizeT {
  pub size_: u32,
}
impl Default for VertexSizeT {
  fn default() -> Self {
    Self {
      size_: 0,
    }
  }
}
impl VertexSizeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<VertexSize<'b>> {
    let size_ = self.size_;
    VertexSize::create(_fbb, &VertexSizeArgs{
      size_,
    })
  }
}
pub enum VertexAccessorsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VertexAccessors<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VertexAccessors<'a> {
  type Inner = VertexAccessors<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VertexAccessors<'a> {
  pub const VT_ATTRS: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VertexAccessors { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VertexAccessorsArgs<'args>
  ) -> flatbuffers::WIPOffset<VertexAccessors<'bldr>> {
    let mut builder = VertexAccessorsBuilder::new(_fbb);
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.attrs { builder.add_attrs(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> VertexAccessorsT {
    let attrs = self.attrs().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let size_ = self.size_().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    VertexAccessorsT {
      attrs,
      size_,
    }
  }

  #[inline]
  pub fn attrs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexAccessor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexAccessor>>>>(VertexAccessors::VT_ATTRS, None)}
  }
  #[inline]
  pub fn size_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexSize<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexSize>>>>(VertexAccessors::VT_SIZE_, None)}
  }
}

impl flatbuffers::Verifiable for VertexAccessors<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VertexAccessor>>>>("attrs", Self::VT_ATTRS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VertexSize>>>>("size_", Self::VT_SIZE_, false)?
     .finish();
    Ok(())
  }
}
pub struct VertexAccessorsArgs<'a> {
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexAccessor<'a>>>>>,
    pub size_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexSize<'a>>>>>,
}
impl<'a> Default for VertexAccessorsArgs<'a> {
  #[inline]
  fn default() -> Self {
    VertexAccessorsArgs {
      attrs: None,
      size_: None,
    }
  }
}

pub struct VertexAccessorsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VertexAccessorsBuilder<'a, 'b> {
  #[inline]
  pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VertexAccessor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VertexAccessors::VT_ATTRS, attrs);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VertexSize<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VertexAccessors::VT_SIZE_, size_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VertexAccessorsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VertexAccessorsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VertexAccessors<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VertexAccessors<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VertexAccessors");
      ds.field("attrs", &self.attrs());
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VertexAccessorsT {
  pub attrs: Option<Vec<VertexAccessorT>>,
  pub size_: Option<Vec<VertexSizeT>>,
}
impl Default for VertexAccessorsT {
  fn default() -> Self {
    Self {
      attrs: None,
      size_: None,
    }
  }
}
impl VertexAccessorsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<VertexAccessors<'b>> {
    let attrs = self.attrs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let size_ = self.size_.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    VertexAccessors::create(_fbb, &VertexAccessorsArgs{
      attrs,
      size_,
    })
  }
}
pub enum MaterialInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaterialInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaterialInfo<'a> {
  type Inner = MaterialInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MaterialInfo<'a> {
  pub const VT_POLY_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_POLY_OFFSET: flatbuffers::VOffsetT = 6;
  pub const VT_SH_UNK3: flatbuffers::VOffsetT = 8;
  pub const VT_MATERIAL_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_SH_UNK4: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MaterialInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MaterialInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<MaterialInfo<'bldr>> {
    let mut builder = MaterialInfoBuilder::new(_fbb);
    builder.add_sh_unk4(args.sh_unk4);
    if let Some(x) = args.material_name { builder.add_material_name(x); }
    builder.add_sh_unk3(args.sh_unk3);
    builder.add_poly_offset(args.poly_offset);
    builder.add_poly_count(args.poly_count);
    builder.finish()
  }

  pub fn unpack(&self) -> MaterialInfoT {
    let poly_count = self.poly_count();
    let poly_offset = self.poly_offset();
    let sh_unk3 = self.sh_unk3();
    let material_name = self.material_name().map(|x| {
      x.to_string()
    });
    let sh_unk4 = self.sh_unk4();
    MaterialInfoT {
      poly_count,
      poly_offset,
      sh_unk3,
      material_name,
      sh_unk4,
    }
  }

  #[inline]
  pub fn poly_count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MaterialInfo::VT_POLY_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn poly_offset(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MaterialInfo::VT_POLY_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sh_unk3(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MaterialInfo::VT_SH_UNK3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn material_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MaterialInfo::VT_MATERIAL_NAME, None)}
  }
  #[inline]
  pub fn sh_unk4(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MaterialInfo::VT_SH_UNK4, Some(-1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MaterialInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("poly_count", Self::VT_POLY_COUNT, false)?
     .visit_field::<u32>("poly_offset", Self::VT_POLY_OFFSET, false)?
     .visit_field::<u32>("sh_unk3", Self::VT_SH_UNK3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("material_name", Self::VT_MATERIAL_NAME, false)?
     .visit_field::<i32>("sh_unk4", Self::VT_SH_UNK4, false)?
     .finish();
    Ok(())
  }
}
pub struct MaterialInfoArgs<'a> {
    pub poly_count: u32,
    pub poly_offset: u32,
    pub sh_unk3: u32,
    pub material_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sh_unk4: i32,
}
impl<'a> Default for MaterialInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    MaterialInfoArgs {
      poly_count: 0,
      poly_offset: 0,
      sh_unk3: 0,
      material_name: None,
      sh_unk4: -1,
    }
  }
}

pub struct MaterialInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaterialInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_poly_count(&mut self, poly_count: u32) {
    self.fbb_.push_slot::<u32>(MaterialInfo::VT_POLY_COUNT, poly_count, 0);
  }
  #[inline]
  pub fn add_poly_offset(&mut self, poly_offset: u32) {
    self.fbb_.push_slot::<u32>(MaterialInfo::VT_POLY_OFFSET, poly_offset, 0);
  }
  #[inline]
  pub fn add_sh_unk3(&mut self, sh_unk3: u32) {
    self.fbb_.push_slot::<u32>(MaterialInfo::VT_SH_UNK3, sh_unk3, 0);
  }
  #[inline]
  pub fn add_material_name(&mut self, material_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialInfo::VT_MATERIAL_NAME, material_name);
  }
  #[inline]
  pub fn add_sh_unk4(&mut self, sh_unk4: i32) {
    self.fbb_.push_slot::<i32>(MaterialInfo::VT_SH_UNK4, sh_unk4, -1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaterialInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MaterialInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MaterialInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MaterialInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MaterialInfo");
      ds.field("poly_count", &self.poly_count());
      ds.field("poly_offset", &self.poly_offset());
      ds.field("sh_unk3", &self.sh_unk3());
      ds.field("material_name", &self.material_name());
      ds.field("sh_unk4", &self.sh_unk4());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MaterialInfoT {
  pub poly_count: u32,
  pub poly_offset: u32,
  pub sh_unk3: u32,
  pub material_name: Option<String>,
  pub sh_unk4: i32,
}
impl Default for MaterialInfoT {
  fn default() -> Self {
    Self {
      poly_count: 0,
      poly_offset: 0,
      sh_unk3: 0,
      material_name: None,
      sh_unk4: -1,
    }
  }
}
impl MaterialInfoT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MaterialInfo<'b>> {
    let poly_count = self.poly_count;
    let poly_offset = self.poly_offset;
    let sh_unk3 = self.sh_unk3;
    let material_name = self.material_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sh_unk4 = self.sh_unk4;
    MaterialInfo::create(_fbb, &MaterialInfoArgs{
      poly_count,
      poly_offset,
      sh_unk3,
      material_name,
      sh_unk4,
    })
  }
}
pub enum MorphAccessorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MorphAccessor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MorphAccessor<'a> {
  type Inner = MorphAccessor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MorphAccessor<'a> {
  pub const VT_UNK_0: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTE: flatbuffers::VOffsetT = 6;
  pub const VT_UNK_1: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_POSITION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MorphAccessor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MorphAccessorArgs
  ) -> flatbuffers::WIPOffset<MorphAccessor<'bldr>> {
    let mut builder = MorphAccessorBuilder::new(_fbb);
    builder.add_position(args.position);
    builder.add_type_(args.type_);
    builder.add_unk_1(args.unk_1);
    builder.add_attribute(args.attribute);
    builder.add_unk_0(args.unk_0);
    builder.finish()
  }

  pub fn unpack(&self) -> MorphAccessorT {
    let unk_0 = self.unk_0();
    let attribute = self.attribute();
    let unk_1 = self.unk_1();
    let type_ = self.type_();
    let position = self.position();
    MorphAccessorT {
      unk_0,
      attribute,
      unk_1,
      type_,
      position,
    }
  }

  #[inline]
  pub fn unk_0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MorphAccessor::VT_UNK_0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attribute(&self) -> MorphAttribute {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MorphAttribute>(MorphAccessor::VT_ATTRIBUTE, Some(MorphAttribute::NONE)).unwrap()}
  }
  #[inline]
  pub fn unk_1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MorphAccessor::VT_UNK_1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> Type {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Type>(MorphAccessor::VT_TYPE_, Some(Type::NONE)).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MorphAccessor::VT_POSITION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MorphAccessor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("unk_0", Self::VT_UNK_0, false)?
     .visit_field::<MorphAttribute>("attribute", Self::VT_ATTRIBUTE, false)?
     .visit_field::<u32>("unk_1", Self::VT_UNK_1, false)?
     .visit_field::<Type>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u32>("position", Self::VT_POSITION, false)?
     .finish();
    Ok(())
  }
}
pub struct MorphAccessorArgs {
    pub unk_0: u32,
    pub attribute: MorphAttribute,
    pub unk_1: u32,
    pub type_: Type,
    pub position: u32,
}
impl<'a> Default for MorphAccessorArgs {
  #[inline]
  fn default() -> Self {
    MorphAccessorArgs {
      unk_0: 0,
      attribute: MorphAttribute::NONE,
      unk_1: 0,
      type_: Type::NONE,
      position: 0,
    }
  }
}

pub struct MorphAccessorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MorphAccessorBuilder<'a, 'b> {
  #[inline]
  pub fn add_unk_0(&mut self, unk_0: u32) {
    self.fbb_.push_slot::<u32>(MorphAccessor::VT_UNK_0, unk_0, 0);
  }
  #[inline]
  pub fn add_attribute(&mut self, attribute: MorphAttribute) {
    self.fbb_.push_slot::<MorphAttribute>(MorphAccessor::VT_ATTRIBUTE, attribute, MorphAttribute::NONE);
  }
  #[inline]
  pub fn add_unk_1(&mut self, unk_1: u32) {
    self.fbb_.push_slot::<u32>(MorphAccessor::VT_UNK_1, unk_1, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: Type) {
    self.fbb_.push_slot::<Type>(MorphAccessor::VT_TYPE_, type_, Type::NONE);
  }
  #[inline]
  pub fn add_position(&mut self, position: u32) {
    self.fbb_.push_slot::<u32>(MorphAccessor::VT_POSITION, position, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MorphAccessorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MorphAccessorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MorphAccessor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MorphAccessor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MorphAccessor");
      ds.field("unk_0", &self.unk_0());
      ds.field("attribute", &self.attribute());
      ds.field("unk_1", &self.unk_1());
      ds.field("type_", &self.type_());
      ds.field("position", &self.position());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MorphAccessorT {
  pub unk_0: u32,
  pub attribute: MorphAttribute,
  pub unk_1: u32,
  pub type_: Type,
  pub position: u32,
}
impl Default for MorphAccessorT {
  fn default() -> Self {
    Self {
      unk_0: 0,
      attribute: MorphAttribute::NONE,
      unk_1: 0,
      type_: Type::NONE,
      position: 0,
    }
  }
}
impl MorphAccessorT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MorphAccessor<'b>> {
    let unk_0 = self.unk_0;
    let attribute = self.attribute;
    let unk_1 = self.unk_1;
    let type_ = self.type_;
    let position = self.position;
    MorphAccessor::create(_fbb, &MorphAccessorArgs{
      unk_0,
      attribute,
      unk_1,
      type_,
      position,
    })
  }
}
pub enum MorphSizeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MorphSize<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MorphSize<'a> {
  type Inner = MorphSize<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MorphSize<'a> {
  pub const VT_SIZE_: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MorphSize { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MorphSizeArgs
  ) -> flatbuffers::WIPOffset<MorphSize<'bldr>> {
    let mut builder = MorphSizeBuilder::new(_fbb);
    builder.add_size_(args.size_);
    builder.finish()
  }

  pub fn unpack(&self) -> MorphSizeT {
    let size_ = self.size_();
    MorphSizeT {
      size_,
    }
  }

  #[inline]
  pub fn size_(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MorphSize::VT_SIZE_, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MorphSize<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("size_", Self::VT_SIZE_, false)?
     .finish();
    Ok(())
  }
}
pub struct MorphSizeArgs {
    pub size_: u32,
}
impl<'a> Default for MorphSizeArgs {
  #[inline]
  fn default() -> Self {
    MorphSizeArgs {
      size_: 0,
    }
  }
}

pub struct MorphSizeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MorphSizeBuilder<'a, 'b> {
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(MorphSize::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MorphSizeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MorphSizeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MorphSize<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MorphSize<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MorphSize");
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MorphSizeT {
  pub size_: u32,
}
impl Default for MorphSizeT {
  fn default() -> Self {
    Self {
      size_: 0,
    }
  }
}
impl MorphSizeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MorphSize<'b>> {
    let size_ = self.size_;
    MorphSize::create(_fbb, &MorphSizeArgs{
      size_,
    })
  }
}
pub enum MorphDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MorphData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MorphData<'a> {
  type Inner = MorphData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MorphData<'a> {
  pub const VT_ATTRS: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MorphData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MorphDataArgs<'args>
  ) -> flatbuffers::WIPOffset<MorphData<'bldr>> {
    let mut builder = MorphDataBuilder::new(_fbb);
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.attrs { builder.add_attrs(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MorphDataT {
    let attrs = self.attrs().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let size_ = self.size_().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MorphDataT {
      attrs,
      size_,
    }
  }

  #[inline]
  pub fn attrs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphAccessor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphAccessor>>>>(MorphData::VT_ATTRS, None)}
  }
  #[inline]
  pub fn size_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphSize<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphSize>>>>(MorphData::VT_SIZE_, None)}
  }
}

impl flatbuffers::Verifiable for MorphData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphAccessor>>>>("attrs", Self::VT_ATTRS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphSize>>>>("size_", Self::VT_SIZE_, false)?
     .finish();
    Ok(())
  }
}
pub struct MorphDataArgs<'a> {
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphAccessor<'a>>>>>,
    pub size_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphSize<'a>>>>>,
}
impl<'a> Default for MorphDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MorphDataArgs {
      attrs: None,
      size_: None,
    }
  }
}

pub struct MorphDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MorphDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MorphAccessor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MorphData::VT_ATTRS, attrs);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MorphSize<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MorphData::VT_SIZE_, size_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MorphDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MorphDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MorphData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MorphData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MorphData");
      ds.field("attrs", &self.attrs());
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MorphDataT {
  pub attrs: Option<Vec<MorphAccessorT>>,
  pub size_: Option<Vec<MorphSizeT>>,
}
impl Default for MorphDataT {
  fn default() -> Self {
    Self {
      attrs: None,
      size_: None,
    }
  }
}
impl MorphDataT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MorphData<'b>> {
    let attrs = self.attrs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let size_ = self.size_.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MorphData::create(_fbb, &MorphDataArgs{
      attrs,
      size_,
    })
  }
}
pub enum MorphMetaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MorphMetaData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MorphMetaData<'a> {
  type Inner = MorphMetaData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MorphMetaData<'a> {
  pub const VT_MORPH_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_MORPH_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_MORPH_TYPE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MorphMetaData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MorphMetaDataArgs<'args>
  ) -> flatbuffers::WIPOffset<MorphMetaData<'bldr>> {
    let mut builder = MorphMetaDataBuilder::new(_fbb);
    if let Some(x) = args.morph_name { builder.add_morph_name(x); }
    builder.add_morph_index(args.morph_index);
    builder.add_morph_type(args.morph_type);
    builder.finish()
  }

  pub fn unpack(&self) -> MorphMetaDataT {
    let morph_index = self.morph_index();
    let morph_name = self.morph_name().map(|x| {
      x.to_string()
    });
    let morph_type = self.morph_type();
    MorphMetaDataT {
      morph_index,
      morph_name,
      morph_type,
    }
  }

  #[inline]
  pub fn morph_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MorphMetaData::VT_MORPH_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn morph_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MorphMetaData::VT_MORPH_NAME, None)}
  }
  #[inline]
  pub fn morph_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MorphMetaData::VT_MORPH_TYPE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MorphMetaData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("morph_index", Self::VT_MORPH_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("morph_name", Self::VT_MORPH_NAME, false)?
     .visit_field::<u8>("morph_type", Self::VT_MORPH_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct MorphMetaDataArgs<'a> {
    pub morph_index: u32,
    pub morph_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub morph_type: u8,
}
impl<'a> Default for MorphMetaDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MorphMetaDataArgs {
      morph_index: 0,
      morph_name: None,
      morph_type: 0,
    }
  }
}

pub struct MorphMetaDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MorphMetaDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_morph_index(&mut self, morph_index: u32) {
    self.fbb_.push_slot::<u32>(MorphMetaData::VT_MORPH_INDEX, morph_index, 0);
  }
  #[inline]
  pub fn add_morph_name(&mut self, morph_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MorphMetaData::VT_MORPH_NAME, morph_name);
  }
  #[inline]
  pub fn add_morph_type(&mut self, morph_type: u8) {
    self.fbb_.push_slot::<u8>(MorphMetaData::VT_MORPH_TYPE, morph_type, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MorphMetaDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MorphMetaDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MorphMetaData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MorphMetaData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MorphMetaData");
      ds.field("morph_index", &self.morph_index());
      ds.field("morph_name", &self.morph_name());
      ds.field("morph_type", &self.morph_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MorphMetaDataT {
  pub morph_index: u32,
  pub morph_name: Option<String>,
  pub morph_type: u8,
}
impl Default for MorphMetaDataT {
  fn default() -> Self {
    Self {
      morph_index: 0,
      morph_name: None,
      morph_type: 0,
    }
  }
}
impl MorphMetaDataT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MorphMetaData<'b>> {
    let morph_index = self.morph_index;
    let morph_name = self.morph_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let morph_type = self.morph_type;
    MorphMetaData::create(_fbb, &MorphMetaDataArgs{
      morph_index,
      morph_name,
      morph_type,
    })
  }
}
pub enum MorphShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MorphShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MorphShape<'a> {
  type Inner = MorphShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MorphShape<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_METADATA: flatbuffers::VOffsetT = 6;
  pub const VT_MORPH_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MorphShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MorphShapeArgs<'args>
  ) -> flatbuffers::WIPOffset<MorphShape<'bldr>> {
    let mut builder = MorphShapeBuilder::new(_fbb);
    if let Some(x) = args.morph_name { builder.add_morph_name(x); }
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MorphShapeT {
    let data = self.data().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let metadata = self.metadata().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let morph_name = self.morph_name().map(|x| {
      x.to_string()
    });
    MorphShapeT {
      data,
      metadata,
      morph_name,
    }
  }

  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphData>>>>(MorphShape::VT_DATA, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphMetaData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphMetaData>>>>(MorphShape::VT_METADATA, None)}
  }
  #[inline]
  pub fn morph_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MorphShape::VT_MORPH_NAME, None)}
  }
}

impl flatbuffers::Verifiable for MorphShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphData>>>>("data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphMetaData>>>>("metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("morph_name", Self::VT_MORPH_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct MorphShapeArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphData<'a>>>>>,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphMetaData<'a>>>>>,
    pub morph_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MorphShapeArgs<'a> {
  #[inline]
  fn default() -> Self {
    MorphShapeArgs {
      data: None,
      metadata: None,
      morph_name: None,
    }
  }
}

pub struct MorphShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MorphShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MorphData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MorphShape::VT_DATA, data);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MorphMetaData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MorphShape::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_morph_name(&mut self, morph_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MorphShape::VT_MORPH_NAME, morph_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MorphShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MorphShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MorphShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MorphShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MorphShape");
      ds.field("data", &self.data());
      ds.field("metadata", &self.metadata());
      ds.field("morph_name", &self.morph_name());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MorphShapeT {
  pub data: Option<Vec<MorphDataT>>,
  pub metadata: Option<Vec<MorphMetaDataT>>,
  pub morph_name: Option<String>,
}
impl Default for MorphShapeT {
  fn default() -> Self {
    Self {
      data: None,
      metadata: None,
      morph_name: None,
    }
  }
}
impl MorphShapeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MorphShape<'b>> {
    let data = self.data.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let metadata = self.metadata.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let morph_name = self.morph_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MorphShape::create(_fbb, &MorphShapeArgs{
      data,
      metadata,
      morph_name,
    })
  }
}
pub enum VisShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VisShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VisShape<'a> {
  type Inner = VisShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VisShape<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VisShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VisShapeArgs<'args>
  ) -> flatbuffers::WIPOffset<VisShape<'bldr>> {
    let mut builder = VisShapeBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_index(args.index);
    builder.finish()
  }

  pub fn unpack(&self) -> VisShapeT {
    let index = self.index();
    let name = self.name().map(|x| {
      x.to_string()
    });
    VisShapeT {
      index,
      name,
    }
  }

  #[inline]
  pub fn index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VisShape::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VisShape::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for VisShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct VisShapeArgs<'a> {
    pub index: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for VisShapeArgs<'a> {
  #[inline]
  fn default() -> Self {
    VisShapeArgs {
      index: 0,
      name: None,
    }
  }
}

pub struct VisShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VisShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(VisShape::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VisShape::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VisShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VisShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VisShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VisShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VisShape");
      ds.field("index", &self.index());
      ds.field("name", &self.name());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VisShapeT {
  pub index: u32,
  pub name: Option<String>,
}
impl Default for VisShapeT {
  fn default() -> Self {
    Self {
      index: 0,
      name: None,
    }
  }
}
impl VisShapeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<VisShape<'b>> {
    let index = self.index;
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    VisShape::create(_fbb, &VisShapeArgs{
      index,
      name,
    })
  }
}
pub enum MeshShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MeshShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MeshShape<'a> {
  type Inner = MeshShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MeshShape<'a> {
  pub const VT_MESH_SHAPE_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_BOUNDS: flatbuffers::VOffsetT = 6;
  pub const VT_POLYGON_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
  pub const VT_MATERIALS: flatbuffers::VOffsetT = 12;
  pub const VT_RES0: flatbuffers::VOffsetT = 14;
  pub const VT_RES1: flatbuffers::VOffsetT = 16;
  pub const VT_RES2: flatbuffers::VOffsetT = 18;
  pub const VT_RES3: flatbuffers::VOffsetT = 20;
  pub const VT_CLIP_SPHERE: flatbuffers::VOffsetT = 22;
  pub const VT_INFLUENCE: flatbuffers::VOffsetT = 24;
  pub const VT_VIS_SHAPES: flatbuffers::VOffsetT = 26;
  pub const VT_MESH_NAME: flatbuffers::VOffsetT = 28;
  pub const VT_UNK13: flatbuffers::VOffsetT = 30;
  pub const VT_MORPH_SHAPE: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MeshShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MeshShapeArgs<'args>
  ) -> flatbuffers::WIPOffset<MeshShape<'bldr>> {
    let mut builder = MeshShapeBuilder::new(_fbb);
    if let Some(x) = args.morph_shape { builder.add_morph_shape(x); }
    builder.add_unk13(args.unk13);
    if let Some(x) = args.mesh_name { builder.add_mesh_name(x); }
    if let Some(x) = args.vis_shapes { builder.add_vis_shapes(x); }
    if let Some(x) = args.influence { builder.add_influence(x); }
    if let Some(x) = args.clip_sphere { builder.add_clip_sphere(x); }
    builder.add_res3(args.res3);
    builder.add_res2(args.res2);
    builder.add_res1(args.res1);
    builder.add_res0(args.res0);
    if let Some(x) = args.materials { builder.add_materials(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    builder.add_polygon_type(args.polygon_type);
    if let Some(x) = args.bounds { builder.add_bounds(x); }
    if let Some(x) = args.mesh_shape_name { builder.add_mesh_shape_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MeshShapeT {
    let mesh_shape_name = self.mesh_shape_name().map(|x| {
      x.to_string()
    });
    let bounds = self.bounds().map(|x| {
      Box::new(x.unpack())
    });
    let polygon_type = self.polygon_type();
    let attributes = self.attributes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let materials = self.materials().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let res0 = self.res0();
    let res1 = self.res1();
    let res2 = self.res2();
    let res3 = self.res3();
    let clip_sphere = self.clip_sphere().map(|x| {
      x.unpack()
    });
    let influence = self.influence().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let vis_shapes = self.vis_shapes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let mesh_name = self.mesh_name().map(|x| {
      x.to_string()
    });
    let unk13 = self.unk13();
    let morph_shape = self.morph_shape().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MeshShapeT {
      mesh_shape_name,
      bounds,
      polygon_type,
      attributes,
      materials,
      res0,
      res1,
      res2,
      res3,
      clip_sphere,
      influence,
      vis_shapes,
      mesh_name,
      unk13,
      morph_shape,
    }
  }

  #[inline]
  pub fn mesh_shape_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MeshShape::VT_MESH_SHAPE_NAME, None)}
  }
  #[inline]
  pub fn bounds(&self) -> Option<BoundingBox<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BoundingBox>>(MeshShape::VT_BOUNDS, None)}
  }
  #[inline]
  pub fn polygon_type(&self) -> PolygonType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PolygonType>(MeshShape::VT_POLYGON_TYPE, Some(PolygonType::X8_Y8_Z8_UNSIGNED)).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexAccessors<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexAccessors>>>>(MeshShape::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn materials(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialInfo>>>>(MeshShape::VT_MATERIALS, None)}
  }
  #[inline]
  pub fn res0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MeshShape::VT_RES0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn res1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MeshShape::VT_RES1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn res2(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MeshShape::VT_RES2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn res3(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MeshShape::VT_RES3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn clip_sphere(&self) -> Option<&'a Sphere> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Sphere>(MeshShape::VT_CLIP_SPHERE, None)}
  }
  #[inline]
  pub fn influence(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Influence<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Influence>>>>(MeshShape::VT_INFLUENCE, None)}
  }
  #[inline]
  pub fn vis_shapes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VisShape<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VisShape>>>>(MeshShape::VT_VIS_SHAPES, None)}
  }
  #[inline]
  pub fn mesh_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MeshShape::VT_MESH_NAME, None)}
  }
  #[inline]
  pub fn unk13(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MeshShape::VT_UNK13, Some(0)).unwrap()}
  }
  #[inline]
  pub fn morph_shape(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphShape<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphShape>>>>(MeshShape::VT_MORPH_SHAPE, None)}
  }
}

impl flatbuffers::Verifiable for MeshShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mesh_shape_name", Self::VT_MESH_SHAPE_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BoundingBox>>("bounds", Self::VT_BOUNDS, false)?
     .visit_field::<PolygonType>("polygon_type", Self::VT_POLYGON_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VertexAccessors>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MaterialInfo>>>>("materials", Self::VT_MATERIALS, false)?
     .visit_field::<u32>("res0", Self::VT_RES0, false)?
     .visit_field::<u32>("res1", Self::VT_RES1, false)?
     .visit_field::<u32>("res2", Self::VT_RES2, false)?
     .visit_field::<u32>("res3", Self::VT_RES3, false)?
     .visit_field::<Sphere>("clip_sphere", Self::VT_CLIP_SPHERE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Influence>>>>("influence", Self::VT_INFLUENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VisShape>>>>("vis_shapes", Self::VT_VIS_SHAPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mesh_name", Self::VT_MESH_NAME, false)?
     .visit_field::<u32>("unk13", Self::VT_UNK13, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphShape>>>>("morph_shape", Self::VT_MORPH_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct MeshShapeArgs<'a> {
    pub mesh_shape_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bounds: Option<flatbuffers::WIPOffset<BoundingBox<'a>>>,
    pub polygon_type: PolygonType,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VertexAccessors<'a>>>>>,
    pub materials: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialInfo<'a>>>>>,
    pub res0: u32,
    pub res1: u32,
    pub res2: u32,
    pub res3: u32,
    pub clip_sphere: Option<&'a Sphere>,
    pub influence: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Influence<'a>>>>>,
    pub vis_shapes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VisShape<'a>>>>>,
    pub mesh_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk13: u32,
    pub morph_shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphShape<'a>>>>>,
}
impl<'a> Default for MeshShapeArgs<'a> {
  #[inline]
  fn default() -> Self {
    MeshShapeArgs {
      mesh_shape_name: None,
      bounds: None,
      polygon_type: PolygonType::X8_Y8_Z8_UNSIGNED,
      attributes: None,
      materials: None,
      res0: 0,
      res1: 0,
      res2: 0,
      res3: 0,
      clip_sphere: None,
      influence: None,
      vis_shapes: None,
      mesh_name: None,
      unk13: 0,
      morph_shape: None,
    }
  }
}

pub struct MeshShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MeshShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_mesh_shape_name(&mut self, mesh_shape_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_MESH_SHAPE_NAME, mesh_shape_name);
  }
  #[inline]
  pub fn add_bounds(&mut self, bounds: flatbuffers::WIPOffset<BoundingBox<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BoundingBox>>(MeshShape::VT_BOUNDS, bounds);
  }
  #[inline]
  pub fn add_polygon_type(&mut self, polygon_type: PolygonType) {
    self.fbb_.push_slot::<PolygonType>(MeshShape::VT_POLYGON_TYPE, polygon_type, PolygonType::X8_Y8_Z8_UNSIGNED);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VertexAccessors<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_materials(&mut self, materials: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MaterialInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_MATERIALS, materials);
  }
  #[inline]
  pub fn add_res0(&mut self, res0: u32) {
    self.fbb_.push_slot::<u32>(MeshShape::VT_RES0, res0, 0);
  }
  #[inline]
  pub fn add_res1(&mut self, res1: u32) {
    self.fbb_.push_slot::<u32>(MeshShape::VT_RES1, res1, 0);
  }
  #[inline]
  pub fn add_res2(&mut self, res2: u32) {
    self.fbb_.push_slot::<u32>(MeshShape::VT_RES2, res2, 0);
  }
  #[inline]
  pub fn add_res3(&mut self, res3: u32) {
    self.fbb_.push_slot::<u32>(MeshShape::VT_RES3, res3, 0);
  }
  #[inline]
  pub fn add_clip_sphere(&mut self, clip_sphere: &Sphere) {
    self.fbb_.push_slot_always::<&Sphere>(MeshShape::VT_CLIP_SPHERE, clip_sphere);
  }
  #[inline]
  pub fn add_influence(&mut self, influence: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Influence<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_INFLUENCE, influence);
  }
  #[inline]
  pub fn add_vis_shapes(&mut self, vis_shapes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VisShape<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_VIS_SHAPES, vis_shapes);
  }
  #[inline]
  pub fn add_mesh_name(&mut self, mesh_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_MESH_NAME, mesh_name);
  }
  #[inline]
  pub fn add_unk13(&mut self, unk13: u32) {
    self.fbb_.push_slot::<u32>(MeshShape::VT_UNK13, unk13, 0);
  }
  #[inline]
  pub fn add_morph_shape(&mut self, morph_shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MorphShape<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshShape::VT_MORPH_SHAPE, morph_shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MeshShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MeshShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MeshShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MeshShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MeshShape");
      ds.field("mesh_shape_name", &self.mesh_shape_name());
      ds.field("bounds", &self.bounds());
      ds.field("polygon_type", &self.polygon_type());
      ds.field("attributes", &self.attributes());
      ds.field("materials", &self.materials());
      ds.field("res0", &self.res0());
      ds.field("res1", &self.res1());
      ds.field("res2", &self.res2());
      ds.field("res3", &self.res3());
      ds.field("clip_sphere", &self.clip_sphere());
      ds.field("influence", &self.influence());
      ds.field("vis_shapes", &self.vis_shapes());
      ds.field("mesh_name", &self.mesh_name());
      ds.field("unk13", &self.unk13());
      ds.field("morph_shape", &self.morph_shape());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MeshShapeT {
  pub mesh_shape_name: Option<String>,
  pub bounds: Option<Box<BoundingBoxT>>,
  pub polygon_type: PolygonType,
  pub attributes: Option<Vec<VertexAccessorsT>>,
  pub materials: Option<Vec<MaterialInfoT>>,
  pub res0: u32,
  pub res1: u32,
  pub res2: u32,
  pub res3: u32,
  pub clip_sphere: Option<SphereT>,
  pub influence: Option<Vec<InfluenceT>>,
  pub vis_shapes: Option<Vec<VisShapeT>>,
  pub mesh_name: Option<String>,
  pub unk13: u32,
  pub morph_shape: Option<Vec<MorphShapeT>>,
}
impl Default for MeshShapeT {
  fn default() -> Self {
    Self {
      mesh_shape_name: None,
      bounds: None,
      polygon_type: PolygonType::X8_Y8_Z8_UNSIGNED,
      attributes: None,
      materials: None,
      res0: 0,
      res1: 0,
      res2: 0,
      res3: 0,
      clip_sphere: None,
      influence: None,
      vis_shapes: None,
      mesh_name: None,
      unk13: 0,
      morph_shape: None,
    }
  }
}
impl MeshShapeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MeshShape<'b>> {
    let mesh_shape_name = self.mesh_shape_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bounds = self.bounds.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let polygon_type = self.polygon_type;
    let attributes = self.attributes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let materials = self.materials.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let res0 = self.res0;
    let res1 = self.res1;
    let res2 = self.res2;
    let res3 = self.res3;
    let clip_sphere_tmp = self.clip_sphere.as_ref().map(|x| x.pack());
    let clip_sphere = clip_sphere_tmp.as_ref();
    let influence = self.influence.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let vis_shapes = self.vis_shapes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let mesh_name = self.mesh_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let unk13 = self.unk13;
    let morph_shape = self.morph_shape.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MeshShape::create(_fbb, &MeshShapeArgs{
      mesh_shape_name,
      bounds,
      polygon_type,
      attributes,
      materials,
      res0,
      res1,
      res2,
      res3,
      clip_sphere,
      influence,
      vis_shapes,
      mesh_name,
      unk13,
      morph_shape,
    })
  }
}
pub enum TRMSHOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TRMSH<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TRMSH<'a> {
  type Inner = TRMSH<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TRMSH<'a> {
  pub const VT_UNK0: flatbuffers::VOffsetT = 4;
  pub const VT_MESHES: flatbuffers::VOffsetT = 6;
  pub const VT_BUFFER_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TRMSH { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TRMSHArgs<'args>
  ) -> flatbuffers::WIPOffset<TRMSH<'bldr>> {
    let mut builder = TRMSHBuilder::new(_fbb);
    if let Some(x) = args.buffer_name { builder.add_buffer_name(x); }
    if let Some(x) = args.meshes { builder.add_meshes(x); }
    builder.add_unk0(args.unk0);
    builder.finish()
  }

  pub fn unpack(&self) -> TRMSHT {
    let unk0 = self.unk0();
    let meshes = self.meshes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let buffer_name = self.buffer_name().map(|x| {
      x.to_string()
    });
    TRMSHT {
      unk0,
      meshes,
      buffer_name,
    }
  }

  #[inline]
  pub fn unk0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TRMSH::VT_UNK0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn meshes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MeshShape<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MeshShape>>>>(TRMSH::VT_MESHES, None)}
  }
  #[inline]
  pub fn buffer_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRMSH::VT_BUFFER_NAME, None)}
  }
}

impl flatbuffers::Verifiable for TRMSH<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("unk0", Self::VT_UNK0, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MeshShape>>>>("meshes", Self::VT_MESHES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffer_name", Self::VT_BUFFER_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct TRMSHArgs<'a> {
    pub unk0: u32,
    pub meshes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MeshShape<'a>>>>>,
    pub buffer_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TRMSHArgs<'a> {
  #[inline]
  fn default() -> Self {
    TRMSHArgs {
      unk0: 0,
      meshes: None,
      buffer_name: None,
    }
  }
}

pub struct TRMSHBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TRMSHBuilder<'a, 'b> {
  #[inline]
  pub fn add_unk0(&mut self, unk0: u32) {
    self.fbb_.push_slot::<u32>(TRMSH::VT_UNK0, unk0, 0);
  }
  #[inline]
  pub fn add_meshes(&mut self, meshes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MeshShape<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRMSH::VT_MESHES, meshes);
  }
  #[inline]
  pub fn add_buffer_name(&mut self, buffer_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRMSH::VT_BUFFER_NAME, buffer_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRMSHBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TRMSHBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TRMSH<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TRMSH<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TRMSH");
      ds.field("unk0", &self.unk0());
      ds.field("meshes", &self.meshes());
      ds.field("buffer_name", &self.buffer_name());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TRMSHT {
  pub unk0: u32,
  pub meshes: Option<Vec<MeshShapeT>>,
  pub buffer_name: Option<String>,
}
impl Default for TRMSHT {
  fn default() -> Self {
    Self {
      unk0: 0,
      meshes: None,
      buffer_name: None,
    }
  }
}
impl TRMSHT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TRMSH<'b>> {
    let unk0 = self.unk0;
    let meshes = self.meshes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let buffer_name = self.buffer_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    TRMSH::create(_fbb, &TRMSHArgs{
      unk0,
      meshes,
      buffer_name,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TRMSH`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trmsh_unchecked`.
pub fn root_as_trmsh(buf: &[u8]) -> Result<TRMSH, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TRMSH>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TRMSH` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_trmsh_unchecked`.
pub fn size_prefixed_root_as_trmsh(buf: &[u8]) -> Result<TRMSH, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TRMSH>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TRMSH` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trmsh_unchecked`.
pub fn root_as_trmsh_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRMSH<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TRMSH<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TRMSH` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trmsh_unchecked`.
pub fn size_prefixed_root_as_trmsh_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRMSH<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TRMSH<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TRMSH and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TRMSH`.
pub unsafe fn root_as_trmsh_unchecked(buf: &[u8]) -> TRMSH {
  flatbuffers::root_unchecked::<TRMSH>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TRMSH and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TRMSH`.
pub unsafe fn size_prefixed_root_as_trmsh_unchecked(buf: &[u8]) -> TRMSH {
  flatbuffers::size_prefixed_root_unchecked::<TRMSH>(buf)
}
pub const TRMSH_EXTENSION: &str = "trmsh";

#[inline]
pub fn finish_trmsh_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<TRMSH<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_trmsh_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<TRMSH<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Model
}  // pub mod Titan

