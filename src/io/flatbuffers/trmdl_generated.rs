// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod model {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        // struct Vec3, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Vec3(pub [u8; 12]);
        impl Default for Vec3 {
            fn default() -> Self {
                Self([0; 12])
            }
        }
        impl core::fmt::Debug for Vec3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vec3")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .field("z", &self.z())
                    .finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
        impl<'a> flatbuffers::Follow<'a> for Vec3 {
            type Inner = &'a Vec3;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Vec3>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
            type Inner = &'a Vec3;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Vec3 {
            type Output = Vec3;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src =
                    ::core::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size());
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Vec3 {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Vec3 {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: f32, y: f32, z: f32) -> Self {
                let mut s = Self([0; 12]);
                s.set_x(x);
                s.set_y(y);
                s.set_z(z);
                s
            }

            pub fn x(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn z(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_z(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> Vec3T {
                Vec3T {
                    x: self.x(),
                    y: self.y(),
                    z: self.z(),
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct Vec3T {
            pub x: f32,
            pub y: f32,
            pub z: f32,
        }
        impl Vec3T {
            pub fn pack(&self) -> Vec3 {
                Vec3::new(self.x, self.y, self.z)
            }
        }

        // struct Vec4, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Vec4(pub [u8; 16]);
        impl Default for Vec4 {
            fn default() -> Self {
                Self([0; 16])
            }
        }
        impl core::fmt::Debug for Vec4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vec4")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .field("z", &self.z())
                    .field("w", &self.w())
                    .finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Vec4 {}
        impl<'a> flatbuffers::Follow<'a> for Vec4 {
            type Inner = &'a Vec4;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Vec4>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Vec4 {
            type Inner = &'a Vec4;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Vec4>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Vec4 {
            type Output = Vec4;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src =
                    ::core::slice::from_raw_parts(self as *const Vec4 as *const u8, Self::size());
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Vec4 {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Vec4 {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: f32, y: f32, z: f32, w: f32) -> Self {
                let mut s = Self([0; 16]);
                s.set_x(x);
                s.set_y(y);
                s.set_z(z);
                s.set_w(w);
                s
            }

            pub fn x(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn z(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_z(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn w(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[12..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_w(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[12..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> Vec4T {
                Vec4T {
                    x: self.x(),
                    y: self.y(),
                    z: self.z(),
                    w: self.w(),
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct Vec4T {
            pub x: f32,
            pub y: f32,
            pub z: f32,
            pub w: f32,
        }
        impl Vec4T {
            pub fn pack(&self) -> Vec4 {
                Vec4::new(self.x, self.y, self.z, self.w)
            }
        }

        pub enum trmeshesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct trmeshes<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for trmeshes<'a> {
            type Inner = trmeshes<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> trmeshes<'a> {
            pub const VT_FILENAME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                trmeshes { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args trmeshesArgs<'args>,
            ) -> flatbuffers::WIPOffset<trmeshes<'bldr>> {
                let mut builder = trmeshesBuilder::new(_fbb);
                if let Some(x) = args.filename {
                    builder.add_filename(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> trmeshesT {
                let filename = self.filename().map(|x| x.to_string());
                trmeshesT { filename }
            }

            #[inline]
            pub fn filename(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(trmeshes::VT_FILENAME, None)
                }
            }
        }

        impl flatbuffers::Verifiable for trmeshes<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "filename",
                        Self::VT_FILENAME,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct trmeshesArgs<'a> {
            pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for trmeshesArgs<'a> {
            #[inline]
            fn default() -> Self {
                trmeshesArgs { filename: None }
            }
        }

        pub struct trmeshesBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> trmeshesBuilder<'a, 'b> {
            #[inline]
            pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(trmeshes::VT_FILENAME, filename);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> trmeshesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                trmeshesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<trmeshes<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for trmeshes<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("trmeshes");
                ds.field("filename", &self.filename());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct trmeshesT {
            pub filename: Option<String>,
        }
        impl Default for trmeshesT {
            fn default() -> Self {
                Self { filename: None }
            }
        }
        impl trmeshesT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<trmeshes<'b>> {
                let filename = self.filename.as_ref().map(|x| _fbb.create_string(x));
                trmeshes::create(_fbb, &trmeshesArgs { filename })
            }
        }
        pub enum trskeletonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct trskeleton<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for trskeleton<'a> {
            type Inner = trskeleton<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> trskeleton<'a> {
            pub const VT_FILENAME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                trskeleton { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args trskeletonArgs<'args>,
            ) -> flatbuffers::WIPOffset<trskeleton<'bldr>> {
                let mut builder = trskeletonBuilder::new(_fbb);
                if let Some(x) = args.filename {
                    builder.add_filename(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> trskeletonT {
                let filename = self.filename().map(|x| x.to_string());
                trskeletonT { filename }
            }

            #[inline]
            pub fn filename(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(trskeleton::VT_FILENAME, None)
                }
            }
        }

        impl flatbuffers::Verifiable for trskeleton<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "filename",
                        Self::VT_FILENAME,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct trskeletonArgs<'a> {
            pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for trskeletonArgs<'a> {
            #[inline]
            fn default() -> Self {
                trskeletonArgs { filename: None }
            }
        }

        pub struct trskeletonBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> trskeletonBuilder<'a, 'b> {
            #[inline]
            pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    trskeleton::VT_FILENAME,
                    filename,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> trskeletonBuilder<'a, 'b> {
                let start = _fbb.start_table();
                trskeletonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<trskeleton<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for trskeleton<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("trskeleton");
                ds.field("filename", &self.filename());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct trskeletonT {
            pub filename: Option<String>,
        }
        impl Default for trskeletonT {
            fn default() -> Self {
                Self { filename: None }
            }
        }
        impl trskeletonT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<trskeleton<'b>> {
                let filename = self.filename.as_ref().map(|x| _fbb.create_string(x));
                trskeleton::create(_fbb, &trskeletonArgs { filename })
            }
        }
        pub enum LodIndexOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct LodIndex<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for LodIndex<'a> {
            type Inner = LodIndex<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> LodIndex<'a> {
            pub const VT_UNK0: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                LodIndex { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args LodIndexArgs,
            ) -> flatbuffers::WIPOffset<LodIndex<'bldr>> {
                let mut builder = LodIndexBuilder::new(_fbb);
                builder.add_unk0(args.unk0);
                builder.finish()
            }

            pub fn unpack(&self) -> LodIndexT {
                let unk0 = self.unk0();
                LodIndexT { unk0 }
            }

            #[inline]
            pub fn unk0(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(LodIndex::VT_UNK0, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for LodIndex<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("unk0", Self::VT_UNK0, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct LodIndexArgs {
            pub unk0: u32,
        }
        impl<'a> Default for LodIndexArgs {
            #[inline]
            fn default() -> Self {
                LodIndexArgs { unk0: 0 }
            }
        }

        pub struct LodIndexBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> LodIndexBuilder<'a, 'b> {
            #[inline]
            pub fn add_unk0(&mut self, unk0: u32) {
                self.fbb_.push_slot::<u32>(LodIndex::VT_UNK0, unk0, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> LodIndexBuilder<'a, 'b> {
                let start = _fbb.start_table();
                LodIndexBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<LodIndex<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for LodIndex<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("LodIndex");
                ds.field("unk0", &self.unk0());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct LodIndexT {
            pub unk0: u32,
        }
        impl Default for LodIndexT {
            fn default() -> Self {
                Self { unk0: 0 }
            }
        }
        impl LodIndexT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<LodIndex<'b>> {
                let unk0 = self.unk0;
                LodIndex::create(_fbb, &LodIndexArgs { unk0 })
            }
        }
        pub enum LodOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Lod<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Lod<'a> {
            type Inner = Lod<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Lod<'a> {
            pub const VT_INDEX: flatbuffers::VOffsetT = 4;
            pub const VT_LOD_TYPE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Lod { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args LodArgs<'args>,
            ) -> flatbuffers::WIPOffset<Lod<'bldr>> {
                let mut builder = LodBuilder::new(_fbb);
                if let Some(x) = args.lod_type {
                    builder.add_lod_type(x);
                }
                if let Some(x) = args.index {
                    builder.add_index(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> LodT {
                let index = self.index().map(|x| x.iter().map(|t| t.unpack()).collect());
                let lod_type = self.lod_type().map(|x| x.to_string());
                LodT { index, lod_type }
            }

            #[inline]
            pub fn index(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LodIndex<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LodIndex>>,
                    >>(Lod::VT_INDEX, None)
                }
            }
            #[inline]
            pub fn lod_type(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(Lod::VT_LOD_TYPE, None)
                }
            }
        }

        impl flatbuffers::Verifiable for Lod<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LodIndex>>,
                    >>("index", Self::VT_INDEX, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "lod_type",
                        Self::VT_LOD_TYPE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct LodArgs<'a> {
            pub index: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LodIndex<'a>>>,
                >,
            >,
            pub lod_type: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for LodArgs<'a> {
            #[inline]
            fn default() -> Self {
                LodArgs {
                    index: None,
                    lod_type: None,
                }
            }
        }

        pub struct LodBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> LodBuilder<'a, 'b> {
            #[inline]
            pub fn add_index(
                &mut self,
                index: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<LodIndex<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Lod::VT_INDEX, index);
            }
            #[inline]
            pub fn add_lod_type(&mut self, lod_type: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Lod::VT_LOD_TYPE, lod_type);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LodBuilder<'a, 'b> {
                let start = _fbb.start_table();
                LodBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Lod<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Lod<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Lod");
                ds.field("index", &self.index());
                ds.field("lod_type", &self.lod_type());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct LodT {
            pub index: Option<Vec<LodIndexT>>,
            pub lod_type: Option<String>,
        }
        impl Default for LodT {
            fn default() -> Self {
                Self {
                    index: None,
                    lod_type: None,
                }
            }
        }
        impl LodT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Lod<'b>> {
                let index = self.index.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let lod_type = self.lod_type.as_ref().map(|x| _fbb.create_string(x));
                Lod::create(_fbb, &LodArgs { index, lod_type })
            }
        }
        pub enum BoundsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Bounds<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Bounds<'a> {
            type Inner = Bounds<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Bounds<'a> {
            pub const VT_MIN: flatbuffers::VOffsetT = 4;
            pub const VT_MAX: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Bounds { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoundsArgs<'args>,
            ) -> flatbuffers::WIPOffset<Bounds<'bldr>> {
                let mut builder = BoundsBuilder::new(_fbb);
                if let Some(x) = args.max {
                    builder.add_max(x);
                }
                if let Some(x) = args.min {
                    builder.add_min(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> BoundsT {
                let min = self.min().map(|x| x.unpack());
                let max = self.max().map(|x| x.unpack());
                BoundsT { min, max }
            }

            #[inline]
            pub fn min(&self) -> Option<&'a Vec3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec3>(Bounds::VT_MIN, None) }
            }
            #[inline]
            pub fn max(&self) -> Option<&'a Vec3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec3>(Bounds::VT_MAX, None) }
            }
        }

        impl flatbuffers::Verifiable for Bounds<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Vec3>("min", Self::VT_MIN, false)?
                    .visit_field::<Vec3>("max", Self::VT_MAX, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BoundsArgs<'a> {
            pub min: Option<&'a Vec3>,
            pub max: Option<&'a Vec3>,
        }
        impl<'a> Default for BoundsArgs<'a> {
            #[inline]
            fn default() -> Self {
                BoundsArgs {
                    min: None,
                    max: None,
                }
            }
        }

        pub struct BoundsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoundsBuilder<'a, 'b> {
            #[inline]
            pub fn add_min(&mut self, min: &Vec3) {
                self.fbb_.push_slot_always::<&Vec3>(Bounds::VT_MIN, min);
            }
            #[inline]
            pub fn add_max(&mut self, max: &Vec3) {
                self.fbb_.push_slot_always::<&Vec3>(Bounds::VT_MAX, max);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoundsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoundsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Bounds<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Bounds<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Bounds");
                ds.field("min", &self.min());
                ds.field("max", &self.max());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct BoundsT {
            pub min: Option<Vec3T>,
            pub max: Option<Vec3T>,
        }
        impl Default for BoundsT {
            fn default() -> Self {
                Self {
                    min: None,
                    max: None,
                }
            }
        }
        impl BoundsT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Bounds<'b>> {
                let min_tmp = self.min.as_ref().map(|x| x.pack());
                let min = min_tmp.as_ref();
                let max_tmp = self.max.as_ref().map(|x| x.pack());
                let max = max_tmp.as_ref();
                Bounds::create(_fbb, &BoundsArgs { min, max })
            }
        }
        pub enum TRMDLOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TRMDL<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TRMDL<'a> {
            type Inner = TRMDL<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TRMDL<'a> {
            pub const VT_UNK0: flatbuffers::VOffsetT = 4;
            pub const VT_MESHES: flatbuffers::VOffsetT = 6;
            pub const VT_SKELETON: flatbuffers::VOffsetT = 8;
            pub const VT_MATERIALS: flatbuffers::VOffsetT = 10;
            pub const VT_LODS: flatbuffers::VOffsetT = 12;
            pub const VT_BOUNDS: flatbuffers::VOffsetT = 14;
            pub const VT_UNK_VEC: flatbuffers::VOffsetT = 16;
            pub const VT_UNK7: flatbuffers::VOffsetT = 18;
            pub const VT_UNK8: flatbuffers::VOffsetT = 20;
            pub const VT_UNK9: flatbuffers::VOffsetT = 22;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TRMDL { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TRMDLArgs<'args>,
            ) -> flatbuffers::WIPOffset<TRMDL<'bldr>> {
                let mut builder = TRMDLBuilder::new(_fbb);
                builder.add_unk9(args.unk9);
                builder.add_unk8(args.unk8);
                builder.add_unk7(args.unk7);
                if let Some(x) = args.unk_vec {
                    builder.add_unk_vec(x);
                }
                if let Some(x) = args.bounds {
                    builder.add_bounds(x);
                }
                if let Some(x) = args.lods {
                    builder.add_lods(x);
                }
                if let Some(x) = args.materials {
                    builder.add_materials(x);
                }
                if let Some(x) = args.skeleton {
                    builder.add_skeleton(x);
                }
                if let Some(x) = args.meshes {
                    builder.add_meshes(x);
                }
                builder.add_unk0(args.unk0);
                builder.finish()
            }

            pub fn unpack(&self) -> TRMDLT {
                let unk0 = self.unk0();
                let meshes = self
                    .meshes()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let skeleton = self.skeleton().map(|x| Box::new(x.unpack()));
                let materials = self
                    .materials()
                    .map(|x| x.iter().map(|s| s.to_string()).collect());
                let lods = self.lods().map(|x| x.iter().map(|t| t.unpack()).collect());
                let bounds = self.bounds().map(|x| Box::new(x.unpack()));
                let unk_vec = self.unk_vec().map(|x| x.unpack());
                let unk7 = self.unk7();
                let unk8 = self.unk8();
                let unk9 = self.unk9();
                TRMDLT {
                    unk0,
                    meshes,
                    skeleton,
                    materials,
                    lods,
                    bounds,
                    unk_vec,
                    unk7,
                    unk8,
                    unk9,
                }
            }

            #[inline]
            pub fn unk0(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMDL::VT_UNK0, Some(0)).unwrap() }
            }
            #[inline]
            pub fn meshes(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<trmeshes<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<trmeshes>>,
                    >>(TRMDL::VT_MESHES, None)
                }
            }
            #[inline]
            pub fn skeleton(&self) -> Option<trskeleton<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<trskeleton>>(TRMDL::VT_SKELETON, None)
                }
            }
            #[inline]
            pub fn materials(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(TRMDL::VT_MATERIALS, None)
                }
            }
            #[inline]
            pub fn lods(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Lod<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Lod>>,
                    >>(TRMDL::VT_LODS, None)
                }
            }
            #[inline]
            pub fn bounds(&self) -> Option<Bounds<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Bounds>>(TRMDL::VT_BOUNDS, None)
                }
            }
            #[inline]
            pub fn unk_vec(&self) -> Option<&'a Vec4> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec4>(TRMDL::VT_UNK_VEC, None) }
            }
            #[inline]
            pub fn unk7(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMDL::VT_UNK7, Some(0)).unwrap() }
            }
            #[inline]
            pub fn unk8(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMDL::VT_UNK8, Some(0)).unwrap() }
            }
            #[inline]
            pub fn unk9(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMDL::VT_UNK9, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for TRMDL<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("unk0", Self::VT_UNK0, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<trmeshes>>,
                    >>("meshes", Self::VT_MESHES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<trskeleton>>(
                        "skeleton",
                        Self::VT_SKELETON,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("materials", Self::VT_MATERIALS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Lod>>,
                    >>("lods", Self::VT_LODS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<Bounds>>(
                        "bounds",
                        Self::VT_BOUNDS,
                        false,
                    )?
                    .visit_field::<Vec4>("unk_vec", Self::VT_UNK_VEC, false)?
                    .visit_field::<u32>("unk7", Self::VT_UNK7, false)?
                    .visit_field::<u32>("unk8", Self::VT_UNK8, false)?
                    .visit_field::<u32>("unk9", Self::VT_UNK9, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TRMDLArgs<'a> {
            pub unk0: u32,
            pub meshes: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<trmeshes<'a>>>,
                >,
            >,
            pub skeleton: Option<flatbuffers::WIPOffset<trskeleton<'a>>>,
            pub materials: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub lods: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Lod<'a>>>,
                >,
            >,
            pub bounds: Option<flatbuffers::WIPOffset<Bounds<'a>>>,
            pub unk_vec: Option<&'a Vec4>,
            pub unk7: u32,
            pub unk8: u32,
            pub unk9: u32,
        }
        impl<'a> Default for TRMDLArgs<'a> {
            #[inline]
            fn default() -> Self {
                TRMDLArgs {
                    unk0: 0,
                    meshes: None,
                    skeleton: None,
                    materials: None,
                    lods: None,
                    bounds: None,
                    unk_vec: None,
                    unk7: 0,
                    unk8: 0,
                    unk9: 0,
                }
            }
        }

        pub struct TRMDLBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TRMDLBuilder<'a, 'b> {
            #[inline]
            pub fn add_unk0(&mut self, unk0: u32) {
                self.fbb_.push_slot::<u32>(TRMDL::VT_UNK0, unk0, 0);
            }
            #[inline]
            pub fn add_meshes(
                &mut self,
                meshes: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<trmeshes<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TRMDL::VT_MESHES, meshes);
            }
            #[inline]
            pub fn add_skeleton(&mut self, skeleton: flatbuffers::WIPOffset<trskeleton<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<trskeleton>>(
                        TRMDL::VT_SKELETON,
                        skeleton,
                    );
            }
            #[inline]
            pub fn add_materials(
                &mut self,
                materials: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TRMDL::VT_MATERIALS, materials);
            }
            #[inline]
            pub fn add_lods(
                &mut self,
                lods: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Lod<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TRMDL::VT_LODS, lods);
            }
            #[inline]
            pub fn add_bounds(&mut self, bounds: flatbuffers::WIPOffset<Bounds<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Bounds>>(TRMDL::VT_BOUNDS, bounds);
            }
            #[inline]
            pub fn add_unk_vec(&mut self, unk_vec: &Vec4) {
                self.fbb_
                    .push_slot_always::<&Vec4>(TRMDL::VT_UNK_VEC, unk_vec);
            }
            #[inline]
            pub fn add_unk7(&mut self, unk7: u32) {
                self.fbb_.push_slot::<u32>(TRMDL::VT_UNK7, unk7, 0);
            }
            #[inline]
            pub fn add_unk8(&mut self, unk8: u32) {
                self.fbb_.push_slot::<u32>(TRMDL::VT_UNK8, unk8, 0);
            }
            #[inline]
            pub fn add_unk9(&mut self, unk9: u32) {
                self.fbb_.push_slot::<u32>(TRMDL::VT_UNK9, unk9, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRMDLBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TRMDLBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TRMDL<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TRMDL<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TRMDL");
                ds.field("unk0", &self.unk0());
                ds.field("meshes", &self.meshes());
                ds.field("skeleton", &self.skeleton());
                ds.field("materials", &self.materials());
                ds.field("lods", &self.lods());
                ds.field("bounds", &self.bounds());
                ds.field("unk_vec", &self.unk_vec());
                ds.field("unk7", &self.unk7());
                ds.field("unk8", &self.unk8());
                ds.field("unk9", &self.unk9());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct TRMDLT {
            pub unk0: u32,
            pub meshes: Option<Vec<trmeshesT>>,
            pub skeleton: Option<Box<trskeletonT>>,
            pub materials: Option<Vec<String>>,
            pub lods: Option<Vec<LodT>>,
            pub bounds: Option<Box<BoundsT>>,
            pub unk_vec: Option<Vec4T>,
            pub unk7: u32,
            pub unk8: u32,
            pub unk9: u32,
        }
        impl Default for TRMDLT {
            fn default() -> Self {
                Self {
                    unk0: 0,
                    meshes: None,
                    skeleton: None,
                    materials: None,
                    lods: None,
                    bounds: None,
                    unk_vec: None,
                    unk7: 0,
                    unk8: 0,
                    unk9: 0,
                }
            }
        }
        impl TRMDLT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TRMDL<'b>> {
                let unk0 = self.unk0;
                let meshes = self.meshes.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let skeleton = self.skeleton.as_ref().map(|x| x.pack(_fbb));
                let materials = self.materials.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                    _fbb.create_vector(&w)
                });
                let lods = self.lods.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let bounds = self.bounds.as_ref().map(|x| x.pack(_fbb));
                let unk_vec_tmp = self.unk_vec.as_ref().map(|x| x.pack());
                let unk_vec = unk_vec_tmp.as_ref();
                let unk7 = self.unk7;
                let unk8 = self.unk8;
                let unk9 = self.unk9;
                TRMDL::create(
                    _fbb,
                    &TRMDLArgs {
                        unk0,
                        meshes,
                        skeleton,
                        materials,
                        lods,
                        bounds,
                        unk_vec,
                        unk7,
                        unk8,
                        unk9,
                    },
                )
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TRMDL`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmdl_unchecked`.
        pub fn root_as_trmdl(buf: &[u8]) -> Result<TRMDL, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TRMDL>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TRMDL` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_trmdl_unchecked`.
        pub fn size_prefixed_root_as_trmdl(
            buf: &[u8],
        ) -> Result<TRMDL, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TRMDL>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TRMDL` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmdl_unchecked`.
        pub fn root_as_trmdl_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TRMDL<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TRMDL<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TRMDL` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmdl_unchecked`.
        pub fn size_prefixed_root_as_trmdl_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TRMDL<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TRMDL<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TRMDL and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TRMDL`.
        pub unsafe fn root_as_trmdl_unchecked(buf: &[u8]) -> TRMDL {
            flatbuffers::root_unchecked::<TRMDL>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TRMDL and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TRMDL`.
        pub unsafe fn size_prefixed_root_as_trmdl_unchecked(buf: &[u8]) -> TRMDL {
            flatbuffers::size_prefixed_root_unchecked::<TRMDL>(buf)
        }
        pub const TRMDL_EXTENSION: &str = "trmdl";

        #[inline]
        pub fn finish_trmdl_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TRMDL<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_trmdl_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TRMDL<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Model
} // pub mod Titan
