// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod model {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        pub enum MaterialSwitchesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MaterialSwitches<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MaterialSwitches<'a> {
            type Inner = MaterialSwitches<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MaterialSwitches<'a> {
            pub const VT_MATERIAL_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_MATERIAL_FLAG: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MaterialSwitches { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MaterialSwitchesArgs<'args>,
            ) -> flatbuffers::WIPOffset<MaterialSwitches<'bldr>> {
                let mut builder = MaterialSwitchesBuilder::new(_fbb);
                if let Some(x) = args.material_name {
                    builder.add_material_name(x);
                }
                builder.add_material_flag(args.material_flag);
                builder.finish()
            }

            pub fn unpack(&self) -> MaterialSwitchesT {
                let material_name = self.material_name().map(|x| x.to_string());
                let material_flag = self.material_flag();
                MaterialSwitchesT {
                    material_name,
                    material_flag,
                }
            }

            #[inline]
            pub fn material_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        MaterialSwitches::VT_MATERIAL_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn material_flag(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(MaterialSwitches::VT_MATERIAL_FLAG, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for MaterialSwitches<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "material_name",
                        Self::VT_MATERIAL_NAME,
                        false,
                    )?
                    .visit_field::<u8>("material_flag", Self::VT_MATERIAL_FLAG, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct MaterialSwitchesArgs<'a> {
            pub material_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub material_flag: u8,
        }
        impl<'a> Default for MaterialSwitchesArgs<'a> {
            #[inline]
            fn default() -> Self {
                MaterialSwitchesArgs {
                    material_name: None,
                    material_flag: 0,
                }
            }
        }

        pub struct MaterialSwitchesBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MaterialSwitchesBuilder<'a, 'b> {
            #[inline]
            pub fn add_material_name(&mut self, material_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialSwitches::VT_MATERIAL_NAME,
                    material_name,
                );
            }
            #[inline]
            pub fn add_material_flag(&mut self, material_flag: u8) {
                self.fbb_
                    .push_slot::<u8>(MaterialSwitches::VT_MATERIAL_FLAG, material_flag, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MaterialSwitchesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MaterialSwitchesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MaterialSwitches<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MaterialSwitches<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MaterialSwitches");
                ds.field("material_name", &self.material_name());
                ds.field("material_flag", &self.material_flag());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct MaterialSwitchesT {
            pub material_name: Option<String>,
            pub material_flag: u8,
        }
        impl Default for MaterialSwitchesT {
            fn default() -> Self {
                Self {
                    material_name: None,
                    material_flag: 0,
                }
            }
        }
        impl MaterialSwitchesT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MaterialSwitches<'b>> {
                let material_name = self.material_name.as_ref().map(|x| _fbb.create_string(x));
                let material_flag = self.material_flag;
                MaterialSwitches::create(
                    _fbb,
                    &MaterialSwitchesArgs {
                        material_name,
                        material_flag,
                    },
                )
            }
        }
        pub enum MaterialMapperOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MaterialMapper<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MaterialMapper<'a> {
            type Inner = MaterialMapper<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MaterialMapper<'a> {
            pub const VT_MESH_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_MATERIAL_NAME: flatbuffers::VOffsetT = 6;
            pub const VT_LAYER_NAME: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MaterialMapper { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MaterialMapperArgs<'args>,
            ) -> flatbuffers::WIPOffset<MaterialMapper<'bldr>> {
                let mut builder = MaterialMapperBuilder::new(_fbb);
                if let Some(x) = args.layer_name {
                    builder.add_layer_name(x);
                }
                if let Some(x) = args.material_name {
                    builder.add_material_name(x);
                }
                if let Some(x) = args.mesh_name {
                    builder.add_mesh_name(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> MaterialMapperT {
                let mesh_name = self.mesh_name().map(|x| x.to_string());
                let material_name = self.material_name().map(|x| x.to_string());
                let layer_name = self.layer_name().map(|x| x.to_string());
                MaterialMapperT {
                    mesh_name,
                    material_name,
                    layer_name,
                }
            }

            #[inline]
            pub fn mesh_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        MaterialMapper::VT_MESH_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn material_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        MaterialMapper::VT_MATERIAL_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn layer_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        MaterialMapper::VT_LAYER_NAME,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for MaterialMapper<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "mesh_name",
                        Self::VT_MESH_NAME,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "material_name",
                        Self::VT_MATERIAL_NAME,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "layer_name",
                        Self::VT_LAYER_NAME,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MaterialMapperArgs<'a> {
            pub mesh_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub material_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub layer_name: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for MaterialMapperArgs<'a> {
            #[inline]
            fn default() -> Self {
                MaterialMapperArgs {
                    mesh_name: None,
                    material_name: None,
                    layer_name: None,
                }
            }
        }

        pub struct MaterialMapperBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MaterialMapperBuilder<'a, 'b> {
            #[inline]
            pub fn add_mesh_name(&mut self, mesh_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialMapper::VT_MESH_NAME,
                    mesh_name,
                );
            }
            #[inline]
            pub fn add_material_name(&mut self, material_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialMapper::VT_MATERIAL_NAME,
                    material_name,
                );
            }
            #[inline]
            pub fn add_layer_name(&mut self, layer_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialMapper::VT_LAYER_NAME,
                    layer_name,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MaterialMapperBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MaterialMapperBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MaterialMapper<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MaterialMapper<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MaterialMapper");
                ds.field("mesh_name", &self.mesh_name());
                ds.field("material_name", &self.material_name());
                ds.field("layer_name", &self.layer_name());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct MaterialMapperT {
            pub mesh_name: Option<String>,
            pub material_name: Option<String>,
            pub layer_name: Option<String>,
        }
        impl Default for MaterialMapperT {
            fn default() -> Self {
                Self {
                    mesh_name: None,
                    material_name: None,
                    layer_name: None,
                }
            }
        }
        impl MaterialMapperT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MaterialMapper<'b>> {
                let mesh_name = self.mesh_name.as_ref().map(|x| _fbb.create_string(x));
                let material_name = self.material_name.as_ref().map(|x| _fbb.create_string(x));
                let layer_name = self.layer_name.as_ref().map(|x| _fbb.create_string(x));
                MaterialMapper::create(
                    _fbb,
                    &MaterialMapperArgs {
                        mesh_name,
                        material_name,
                        layer_name,
                    },
                )
            }
        }
        pub enum EmbeddedTRACMOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct EmbeddedTRACM<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for EmbeddedTRACM<'a> {
            type Inner = EmbeddedTRACM<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> EmbeddedTRACM<'a> {
            pub const VT_BYTEBUFFER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                EmbeddedTRACM { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args EmbeddedTRACMArgs<'args>,
            ) -> flatbuffers::WIPOffset<EmbeddedTRACM<'bldr>> {
                let mut builder = EmbeddedTRACMBuilder::new(_fbb);
                if let Some(x) = args.bytebuffer {
                    builder.add_bytebuffer(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> EmbeddedTRACMT {
                let bytebuffer = self.bytebuffer().map(|x| x.into_iter().collect());
                EmbeddedTRACMT { bytebuffer }
            }

            #[inline]
            pub fn bytebuffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            EmbeddedTRACM::VT_BYTEBUFFER,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for EmbeddedTRACM<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "bytebuffer",
                        Self::VT_BYTEBUFFER,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct EmbeddedTRACMArgs<'a> {
            pub bytebuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for EmbeddedTRACMArgs<'a> {
            #[inline]
            fn default() -> Self {
                EmbeddedTRACMArgs { bytebuffer: None }
            }
        }

        pub struct EmbeddedTRACMBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> EmbeddedTRACMBuilder<'a, 'b> {
            #[inline]
            pub fn add_bytebuffer(
                &mut self,
                bytebuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    EmbeddedTRACM::VT_BYTEBUFFER,
                    bytebuffer,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> EmbeddedTRACMBuilder<'a, 'b> {
                let start = _fbb.start_table();
                EmbeddedTRACMBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<EmbeddedTRACM<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for EmbeddedTRACM<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("EmbeddedTRACM");
                ds.field("bytebuffer", &self.bytebuffer());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct EmbeddedTRACMT {
            pub bytebuffer: Option<Vec<u8>>,
        }
        impl Default for EmbeddedTRACMT {
            fn default() -> Self {
                Self { bytebuffer: None }
            }
        }
        impl EmbeddedTRACMT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<EmbeddedTRACM<'b>> {
                let bytebuffer = self.bytebuffer.as_ref().map(|x| _fbb.create_vector(x));
                EmbeddedTRACM::create(_fbb, &EmbeddedTRACMArgs { bytebuffer })
            }
        }
        pub enum MaterialPropertiesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MaterialProperties<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MaterialProperties<'a> {
            type Inner = MaterialProperties<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MaterialProperties<'a> {
            pub const VT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_MAPPERS: flatbuffers::VOffsetT = 6;
            pub const VT_RES_2: flatbuffers::VOffsetT = 8;
            pub const VT_UNK_3: flatbuffers::VOffsetT = 10;
            pub const VT_TRACM: flatbuffers::VOffsetT = 12;
            pub const VT_RES_5: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MaterialProperties { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MaterialPropertiesArgs<'args>,
            ) -> flatbuffers::WIPOffset<MaterialProperties<'bldr>> {
                let mut builder = MaterialPropertiesBuilder::new(_fbb);
                if let Some(x) = args.res_5 {
                    builder.add_res_5(x);
                }
                if let Some(x) = args.tracm {
                    builder.add_tracm(x);
                }
                builder.add_unk_3(args.unk_3);
                builder.add_res_2(args.res_2);
                if let Some(x) = args.mappers {
                    builder.add_mappers(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> MaterialPropertiesT {
                let name = self.name().map(|x| x.to_string());
                let mappers = self
                    .mappers()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let res_2 = self.res_2();
                let unk_3 = self.unk_3();
                let tracm = self.tracm().map(|x| Box::new(x.unpack()));
                let res_5 = self.res_5().map(|x| x.into_iter().collect());
                MaterialPropertiesT {
                    name,
                    mappers,
                    res_2,
                    unk_3,
                    tracm,
                    res_5,
                }
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        MaterialProperties::VT_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn mappers(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapper<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapper>>,
                    >>(MaterialProperties::VT_MAPPERS, None)
                }
            }
            #[inline]
            pub fn res_2(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(MaterialProperties::VT_RES_2, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn unk_3(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(MaterialProperties::VT_UNK_3, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tracm(&self) -> Option<EmbeddedTRACM<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<EmbeddedTRACM>>(
                            MaterialProperties::VT_TRACM,
                            None,
                        )
                }
            }
            #[inline]
            pub fn res_5(&self) -> Option<flatbuffers::Vector<'a, u32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                            MaterialProperties::VT_RES_5,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for MaterialProperties<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MaterialMapper>>,
                    >>("mappers", Self::VT_MAPPERS, false)?
                    .visit_field::<u32>("res_2", Self::VT_RES_2, false)?
                    .visit_field::<u32>("unk_3", Self::VT_UNK_3, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<EmbeddedTRACM>>(
                        "tracm",
                        Self::VT_TRACM,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                        "res_5",
                        Self::VT_RES_5,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MaterialPropertiesArgs<'a> {
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub mappers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapper<'a>>>,
                >,
            >,
            pub res_2: u32,
            pub unk_3: u32,
            pub tracm: Option<flatbuffers::WIPOffset<EmbeddedTRACM<'a>>>,
            pub res_5: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        }
        impl<'a> Default for MaterialPropertiesArgs<'a> {
            #[inline]
            fn default() -> Self {
                MaterialPropertiesArgs {
                    name: None,
                    mappers: None,
                    res_2: 0,
                    unk_3: 0,
                    tracm: None,
                    res_5: None,
                }
            }
        }

        pub struct MaterialPropertiesBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MaterialPropertiesBuilder<'a, 'b> {
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialProperties::VT_NAME,
                    name,
                );
            }
            #[inline]
            pub fn add_mappers(
                &mut self,
                mappers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MaterialMapper<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialProperties::VT_MAPPERS,
                    mappers,
                );
            }
            #[inline]
            pub fn add_res_2(&mut self, res_2: u32) {
                self.fbb_
                    .push_slot::<u32>(MaterialProperties::VT_RES_2, res_2, 0);
            }
            #[inline]
            pub fn add_unk_3(&mut self, unk_3: u32) {
                self.fbb_
                    .push_slot::<u32>(MaterialProperties::VT_UNK_3, unk_3, 0);
            }
            #[inline]
            pub fn add_tracm(&mut self, tracm: flatbuffers::WIPOffset<EmbeddedTRACM<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<EmbeddedTRACM>>(
                        MaterialProperties::VT_TRACM,
                        tracm,
                    );
            }
            #[inline]
            pub fn add_res_5(
                &mut self,
                res_5: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MaterialProperties::VT_RES_5,
                    res_5,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MaterialPropertiesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MaterialPropertiesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MaterialProperties<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MaterialProperties<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MaterialProperties");
                ds.field("name", &self.name());
                ds.field("mappers", &self.mappers());
                ds.field("res_2", &self.res_2());
                ds.field("unk_3", &self.unk_3());
                ds.field("tracm", &self.tracm());
                ds.field("res_5", &self.res_5());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct MaterialPropertiesT {
            pub name: Option<String>,
            pub mappers: Option<Vec<MaterialMapperT>>,
            pub res_2: u32,
            pub unk_3: u32,
            pub tracm: Option<Box<EmbeddedTRACMT>>,
            pub res_5: Option<Vec<u32>>,
        }
        impl Default for MaterialPropertiesT {
            fn default() -> Self {
                Self {
                    name: None,
                    mappers: None,
                    res_2: 0,
                    unk_3: 0,
                    tracm: None,
                    res_5: None,
                }
            }
        }
        impl MaterialPropertiesT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MaterialProperties<'b>> {
                let name = self.name.as_ref().map(|x| _fbb.create_string(x));
                let mappers = self.mappers.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let res_2 = self.res_2;
                let unk_3 = self.unk_3;
                let tracm = self.tracm.as_ref().map(|x| x.pack(_fbb));
                let res_5 = self.res_5.as_ref().map(|x| _fbb.create_vector(x));
                MaterialProperties::create(
                    _fbb,
                    &MaterialPropertiesArgs {
                        name,
                        mappers,
                        res_2,
                        unk_3,
                        tracm,
                        res_5,
                    },
                )
            }
        }
        pub enum MMTOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MMT<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MMT<'a> {
            type Inner = MMT<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MMT<'a> {
            pub const VT_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_MATERIAL_NAME: flatbuffers::VOffsetT = 6;
            pub const VT_MATERIAL_SWITCHES: flatbuffers::VOffsetT = 8;
            pub const VT_MATERIAL_PROPERTIES: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MMT { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MMTArgs<'args>,
            ) -> flatbuffers::WIPOffset<MMT<'bldr>> {
                let mut builder = MMTBuilder::new(_fbb);
                if let Some(x) = args.material_properties {
                    builder.add_material_properties(x);
                }
                if let Some(x) = args.material_switches {
                    builder.add_material_switches(x);
                }
                if let Some(x) = args.material_name {
                    builder.add_material_name(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> MMTT {
                let name = self.name().map(|x| x.to_string());
                let material_name = self
                    .material_name()
                    .map(|x| x.iter().map(|s| s.to_string()).collect());
                let material_switches = self
                    .material_switches()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let material_properties = self
                    .material_properties()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                MMTT {
                    name,
                    material_name,
                    material_switches,
                    material_properties,
                }
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(MMT::VT_NAME, None)
                }
            }
            #[inline]
            pub fn material_name(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(MMT::VT_MATERIAL_NAME, None)
                }
            }
            #[inline]
            pub fn material_switches(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialSwitches<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialSwitches>>,
                    >>(MMT::VT_MATERIAL_SWITCHES, None)
                }
            }
            #[inline]
            pub fn material_properties(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialProperties<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialProperties>>,
                    >>(MMT::VT_MATERIAL_PROPERTIES, None)
                }
            }
        }

        impl flatbuffers::Verifiable for MMT<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("material_name", Self::VT_MATERIAL_NAME, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MaterialSwitches>>,
                    >>("material_switches", Self::VT_MATERIAL_SWITCHES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MaterialProperties>>,
                    >>(
                        "material_properties", Self::VT_MATERIAL_PROPERTIES, false
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MMTArgs<'a> {
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub material_name: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub material_switches: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialSwitches<'a>>>,
                >,
            >,
            pub material_properties: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialProperties<'a>>>,
                >,
            >,
        }
        impl<'a> Default for MMTArgs<'a> {
            #[inline]
            fn default() -> Self {
                MMTArgs {
                    name: None,
                    material_name: None,
                    material_switches: None,
                    material_properties: None,
                }
            }
        }

        pub struct MMTBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MMTBuilder<'a, 'b> {
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(MMT::VT_NAME, name);
            }
            #[inline]
            pub fn add_material_name(
                &mut self,
                material_name: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MMT::VT_MATERIAL_NAME,
                    material_name,
                );
            }
            #[inline]
            pub fn add_material_switches(
                &mut self,
                material_switches: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MaterialSwitches<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MMT::VT_MATERIAL_SWITCHES,
                    material_switches,
                );
            }
            #[inline]
            pub fn add_material_properties(
                &mut self,
                material_properties: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MaterialProperties<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MMT::VT_MATERIAL_PROPERTIES,
                    material_properties,
                );
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MMTBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MMTBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MMT<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MMT<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MMT");
                ds.field("name", &self.name());
                ds.field("material_name", &self.material_name());
                ds.field("material_switches", &self.material_switches());
                ds.field("material_properties", &self.material_properties());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct MMTT {
            pub name: Option<String>,
            pub material_name: Option<Vec<String>>,
            pub material_switches: Option<Vec<MaterialSwitchesT>>,
            pub material_properties: Option<Vec<MaterialPropertiesT>>,
        }
        impl Default for MMTT {
            fn default() -> Self {
                Self {
                    name: None,
                    material_name: None,
                    material_switches: None,
                    material_properties: None,
                }
            }
        }
        impl MMTT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MMT<'b>> {
                let name = self.name.as_ref().map(|x| _fbb.create_string(x));
                let material_name = self.material_name.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                    _fbb.create_vector(&w)
                });
                let material_switches = self.material_switches.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let material_properties = self.material_properties.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                MMT::create(
                    _fbb,
                    &MMTArgs {
                        name,
                        material_name,
                        material_switches,
                        material_properties,
                    },
                )
            }
        }
        pub enum TRMMTOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TRMMT<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TRMMT<'a> {
            type Inner = TRMMT<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TRMMT<'a> {
            pub const VT_RES_0: flatbuffers::VOffsetT = 4;
            pub const VT_RES_1: flatbuffers::VOffsetT = 6;
            pub const VT_MATERIAL: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TRMMT { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TRMMTArgs<'args>,
            ) -> flatbuffers::WIPOffset<TRMMT<'bldr>> {
                let mut builder = TRMMTBuilder::new(_fbb);
                if let Some(x) = args.material {
                    builder.add_material(x);
                }
                builder.add_res_1(args.res_1);
                builder.add_res_0(args.res_0);
                builder.finish()
            }

            pub fn unpack(&self) -> TRMMTT {
                let res_0 = self.res_0();
                let res_1 = self.res_1();
                let material = self
                    .material()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                TRMMTT {
                    res_0,
                    res_1,
                    material,
                }
            }

            #[inline]
            pub fn res_0(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMMT::VT_RES_0, Some(0)).unwrap() }
            }
            #[inline]
            pub fn res_1(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMMT::VT_RES_1, Some(0)).unwrap() }
            }
            #[inline]
            pub fn material(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MMT<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MMT>>,
                    >>(TRMMT::VT_MATERIAL, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TRMMT<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("res_0", Self::VT_RES_0, false)?
                    .visit_field::<u32>("res_1", Self::VT_RES_1, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MMT>>,
                    >>("material", Self::VT_MATERIAL, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TRMMTArgs<'a> {
            pub res_0: u32,
            pub res_1: u32,
            pub material: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MMT<'a>>>,
                >,
            >,
        }
        impl<'a> Default for TRMMTArgs<'a> {
            #[inline]
            fn default() -> Self {
                TRMMTArgs {
                    res_0: 0,
                    res_1: 0,
                    material: None,
                }
            }
        }

        pub struct TRMMTBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TRMMTBuilder<'a, 'b> {
            #[inline]
            pub fn add_res_0(&mut self, res_0: u32) {
                self.fbb_.push_slot::<u32>(TRMMT::VT_RES_0, res_0, 0);
            }
            #[inline]
            pub fn add_res_1(&mut self, res_1: u32) {
                self.fbb_.push_slot::<u32>(TRMMT::VT_RES_1, res_1, 0);
            }
            #[inline]
            pub fn add_material(
                &mut self,
                material: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MMT<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TRMMT::VT_MATERIAL, material);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRMMTBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TRMMTBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TRMMT<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TRMMT<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TRMMT");
                ds.field("res_0", &self.res_0());
                ds.field("res_1", &self.res_1());
                ds.field("material", &self.material());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct TRMMTT {
            pub res_0: u32,
            pub res_1: u32,
            pub material: Option<Vec<MMTT>>,
        }
        impl Default for TRMMTT {
            fn default() -> Self {
                Self {
                    res_0: 0,
                    res_1: 0,
                    material: None,
                }
            }
        }
        impl TRMMTT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TRMMT<'b>> {
                let res_0 = self.res_0;
                let res_1 = self.res_1;
                let material = self.material.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                TRMMT::create(
                    _fbb,
                    &TRMMTArgs {
                        res_0,
                        res_1,
                        material,
                    },
                )
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TRMMT`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmmt_unchecked`.
        pub fn root_as_trmmt(buf: &[u8]) -> Result<TRMMT, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TRMMT>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TRMMT` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_trmmt_unchecked`.
        pub fn size_prefixed_root_as_trmmt(
            buf: &[u8],
        ) -> Result<TRMMT, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TRMMT>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TRMMT` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmmt_unchecked`.
        pub fn root_as_trmmt_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TRMMT<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TRMMT<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TRMMT` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmmt_unchecked`.
        pub fn size_prefixed_root_as_trmmt_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TRMMT<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TRMMT<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TRMMT and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TRMMT`.
        pub unsafe fn root_as_trmmt_unchecked(buf: &[u8]) -> TRMMT {
            flatbuffers::root_unchecked::<TRMMT>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TRMMT and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TRMMT`.
        pub unsafe fn size_prefixed_root_as_trmmt_unchecked(buf: &[u8]) -> TRMMT {
            flatbuffers::size_prefixed_root_unchecked::<TRMMT>(buf)
        }
        pub const TRMMT_EXTENSION: &str = "trmmt";

        #[inline]
        pub fn finish_trmmt_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TRMMT<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_trmmt_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TRMMT<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Model
} // pub mod Titan
