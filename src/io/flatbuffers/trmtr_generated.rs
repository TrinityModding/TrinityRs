// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod model {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_UVWRAP_MODE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_UVWRAP_MODE: u32 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_UVWRAP_MODE: [UVWrapMode; 4] = [
  UVWrapMode::WRAP,
  UVWrapMode::CLAMP,
  UVWrapMode::MIRROR,
  UVWrapMode::MIRROR_ONCE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UVWrapMode(pub u32);
#[allow(non_upper_case_globals)]
impl UVWrapMode {
  pub const WRAP: Self = Self(0);
  pub const CLAMP: Self = Self(1);
  pub const MIRROR: Self = Self(6);
  pub const MIRROR_ONCE: Self = Self(7);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::WRAP,
    Self::CLAMP,
    Self::MIRROR,
    Self::MIRROR_ONCE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::WRAP => Some("WRAP"),
      Self::CLAMP => Some("CLAMP"),
      Self::MIRROR => Some("MIRROR"),
      Self::MIRROR_ONCE => Some("MIRROR_ONCE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UVWrapMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UVWrapMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for UVWrapMode {
    type Output = UVWrapMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for UVWrapMode {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UVWrapMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UVWrapMode {}
// struct RGBA, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct RGBA(pub [u8; 16]);
impl Default for RGBA { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for RGBA {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("RGBA")
      .field("r", &self.r())
      .field("g", &self.g())
      .field("b", &self.b())
      .field("a", &self.a())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RGBA {}
impl<'a> flatbuffers::Follow<'a> for RGBA {
  type Inner = &'a RGBA;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a RGBA>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a RGBA {
  type Inner = &'a RGBA;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<RGBA>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for RGBA {
    type Output = RGBA;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const RGBA as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for RGBA {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> RGBA {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    r: f32,
    g: f32,
    b: f32,
    a: f32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_r(r);
    s.set_g(g);
    s.set_b(b);
    s.set_a(a);
    s
  }

  pub fn r(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_r(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn g(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_g(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn a(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_a(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> RGBAT {
    RGBAT {
      r: self.r(),
      g: self.g(),
      b: self.b(),
      a: self.a(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct RGBAT {
  pub r: f32,
  pub g: f32,
  pub b: f32,
  pub a: f32,
}
impl RGBAT {
  pub fn pack(&self) -> RGBA {
    RGBA::new(
      self.r,
      self.g,
      self.b,
      self.a,
    )
  }
}

pub enum SamplerStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SamplerState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SamplerState<'a> {
  type Inner = SamplerState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SamplerState<'a> {
  pub const VT_SAMPLERSTATE_0: flatbuffers::VOffsetT = 4;
  pub const VT_SAMPLERSTATE_1: flatbuffers::VOffsetT = 6;
  pub const VT_SAMPLERSTATE_2: flatbuffers::VOffsetT = 8;
  pub const VT_SAMPLERSTATE_3: flatbuffers::VOffsetT = 10;
  pub const VT_SAMPLERSTATE_4: flatbuffers::VOffsetT = 12;
  pub const VT_SAMPLERSTATE_5: flatbuffers::VOffsetT = 14;
  pub const VT_SAMPLERSTATE_6: flatbuffers::VOffsetT = 16;
  pub const VT_SAMPLERSTATE_7: flatbuffers::VOffsetT = 18;
  pub const VT_SAMPLERSTATE_8: flatbuffers::VOffsetT = 20;
  pub const VT_REPEAT_U: flatbuffers::VOffsetT = 22;
  pub const VT_REPEAT_V: flatbuffers::VOffsetT = 24;
  pub const VT_REPEAT_W: flatbuffers::VOffsetT = 26;
  pub const VT_BORDER_COLOR: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SamplerState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SamplerStateArgs<'args>
  ) -> flatbuffers::WIPOffset<SamplerState<'bldr>> {
    let mut builder = SamplerStateBuilder::new(_fbb);
    if let Some(x) = args.border_color { builder.add_border_color(x); }
    builder.add_repeat_w(args.repeat_w);
    builder.add_repeat_v(args.repeat_v);
    builder.add_repeat_u(args.repeat_u);
    builder.add_SamplerState_8(args.SamplerState_8);
    builder.add_SamplerState_7(args.SamplerState_7);
    builder.add_SamplerState_6(args.SamplerState_6);
    builder.add_SamplerState_5(args.SamplerState_5);
    builder.add_SamplerState_4(args.SamplerState_4);
    builder.add_SamplerState_3(args.SamplerState_3);
    builder.add_SamplerState_2(args.SamplerState_2);
    builder.add_SamplerState_1(args.SamplerState_1);
    builder.add_SamplerState_0(args.SamplerState_0);
    builder.finish()
  }

  pub fn unpack(&self) -> SamplerStateT {
    let SamplerState_0 = self.SamplerState_0();
    let SamplerState_1 = self.SamplerState_1();
    let SamplerState_2 = self.SamplerState_2();
    let SamplerState_3 = self.SamplerState_3();
    let SamplerState_4 = self.SamplerState_4();
    let SamplerState_5 = self.SamplerState_5();
    let SamplerState_6 = self.SamplerState_6();
    let SamplerState_7 = self.SamplerState_7();
    let SamplerState_8 = self.SamplerState_8();
    let repeat_u = self.repeat_u();
    let repeat_v = self.repeat_v();
    let repeat_w = self.repeat_w();
    let border_color = self.border_color().map(|x| {
      x.unpack()
    });
    SamplerStateT {
      SamplerState_0,
      SamplerState_1,
      SamplerState_2,
      SamplerState_3,
      SamplerState_4,
      SamplerState_5,
      SamplerState_6,
      SamplerState_7,
      SamplerState_8,
      repeat_u,
      repeat_v,
      repeat_w,
      border_color,
    }
  }

  #[inline]
  pub fn SamplerState_0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_2(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_3(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_5(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_5, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_6(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_6, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_7(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_7, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SamplerState_8(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SamplerState::VT_SAMPLERSTATE_8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn repeat_u(&self) -> UVWrapMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UVWrapMode>(SamplerState::VT_REPEAT_U, Some(UVWrapMode::WRAP)).unwrap()}
  }
  #[inline]
  pub fn repeat_v(&self) -> UVWrapMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UVWrapMode>(SamplerState::VT_REPEAT_V, Some(UVWrapMode::WRAP)).unwrap()}
  }
  #[inline]
  pub fn repeat_w(&self) -> UVWrapMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UVWrapMode>(SamplerState::VT_REPEAT_W, Some(UVWrapMode::WRAP)).unwrap()}
  }
  #[inline]
  pub fn border_color(&self) -> Option<&'a RGBA> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RGBA>(SamplerState::VT_BORDER_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for SamplerState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("SamplerState_0", Self::VT_SAMPLERSTATE_0, false)?
     .visit_field::<u32>("SamplerState_1", Self::VT_SAMPLERSTATE_1, false)?
     .visit_field::<u32>("SamplerState_2", Self::VT_SAMPLERSTATE_2, false)?
     .visit_field::<u32>("SamplerState_3", Self::VT_SAMPLERSTATE_3, false)?
     .visit_field::<u32>("SamplerState_4", Self::VT_SAMPLERSTATE_4, false)?
     .visit_field::<u32>("SamplerState_5", Self::VT_SAMPLERSTATE_5, false)?
     .visit_field::<u32>("SamplerState_6", Self::VT_SAMPLERSTATE_6, false)?
     .visit_field::<u32>("SamplerState_7", Self::VT_SAMPLERSTATE_7, false)?
     .visit_field::<u32>("SamplerState_8", Self::VT_SAMPLERSTATE_8, false)?
     .visit_field::<UVWrapMode>("repeat_u", Self::VT_REPEAT_U, false)?
     .visit_field::<UVWrapMode>("repeat_v", Self::VT_REPEAT_V, false)?
     .visit_field::<UVWrapMode>("repeat_w", Self::VT_REPEAT_W, false)?
     .visit_field::<RGBA>("border_color", Self::VT_BORDER_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct SamplerStateArgs<'a> {
    pub SamplerState_0: u32,
    pub SamplerState_1: u32,
    pub SamplerState_2: u32,
    pub SamplerState_3: u32,
    pub SamplerState_4: u32,
    pub SamplerState_5: u32,
    pub SamplerState_6: u32,
    pub SamplerState_7: u32,
    pub SamplerState_8: u32,
    pub repeat_u: UVWrapMode,
    pub repeat_v: UVWrapMode,
    pub repeat_w: UVWrapMode,
    pub border_color: Option<&'a RGBA>,
}
impl<'a> Default for SamplerStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    SamplerStateArgs {
      SamplerState_0: 0,
      SamplerState_1: 0,
      SamplerState_2: 0,
      SamplerState_3: 0,
      SamplerState_4: 0,
      SamplerState_5: 0,
      SamplerState_6: 0,
      SamplerState_7: 0,
      SamplerState_8: 0,
      repeat_u: UVWrapMode::WRAP,
      repeat_v: UVWrapMode::WRAP,
      repeat_w: UVWrapMode::WRAP,
      border_color: None,
    }
  }
}

pub struct SamplerStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SamplerStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_SamplerState_0(&mut self, SamplerState_0: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_0, SamplerState_0, 0);
  }
  #[inline]
  pub fn add_SamplerState_1(&mut self, SamplerState_1: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_1, SamplerState_1, 0);
  }
  #[inline]
  pub fn add_SamplerState_2(&mut self, SamplerState_2: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_2, SamplerState_2, 0);
  }
  #[inline]
  pub fn add_SamplerState_3(&mut self, SamplerState_3: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_3, SamplerState_3, 0);
  }
  #[inline]
  pub fn add_SamplerState_4(&mut self, SamplerState_4: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_4, SamplerState_4, 0);
  }
  #[inline]
  pub fn add_SamplerState_5(&mut self, SamplerState_5: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_5, SamplerState_5, 0);
  }
  #[inline]
  pub fn add_SamplerState_6(&mut self, SamplerState_6: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_6, SamplerState_6, 0);
  }
  #[inline]
  pub fn add_SamplerState_7(&mut self, SamplerState_7: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_7, SamplerState_7, 0);
  }
  #[inline]
  pub fn add_SamplerState_8(&mut self, SamplerState_8: u32) {
    self.fbb_.push_slot::<u32>(SamplerState::VT_SAMPLERSTATE_8, SamplerState_8, 0);
  }
  #[inline]
  pub fn add_repeat_u(&mut self, repeat_u: UVWrapMode) {
    self.fbb_.push_slot::<UVWrapMode>(SamplerState::VT_REPEAT_U, repeat_u, UVWrapMode::WRAP);
  }
  #[inline]
  pub fn add_repeat_v(&mut self, repeat_v: UVWrapMode) {
    self.fbb_.push_slot::<UVWrapMode>(SamplerState::VT_REPEAT_V, repeat_v, UVWrapMode::WRAP);
  }
  #[inline]
  pub fn add_repeat_w(&mut self, repeat_w: UVWrapMode) {
    self.fbb_.push_slot::<UVWrapMode>(SamplerState::VT_REPEAT_W, repeat_w, UVWrapMode::WRAP);
  }
  #[inline]
  pub fn add_border_color(&mut self, border_color: &RGBA) {
    self.fbb_.push_slot_always::<&RGBA>(SamplerState::VT_BORDER_COLOR, border_color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SamplerStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SamplerStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SamplerState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SamplerState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SamplerState");
      ds.field("SamplerState_0", &self.SamplerState_0());
      ds.field("SamplerState_1", &self.SamplerState_1());
      ds.field("SamplerState_2", &self.SamplerState_2());
      ds.field("SamplerState_3", &self.SamplerState_3());
      ds.field("SamplerState_4", &self.SamplerState_4());
      ds.field("SamplerState_5", &self.SamplerState_5());
      ds.field("SamplerState_6", &self.SamplerState_6());
      ds.field("SamplerState_7", &self.SamplerState_7());
      ds.field("SamplerState_8", &self.SamplerState_8());
      ds.field("repeat_u", &self.repeat_u());
      ds.field("repeat_v", &self.repeat_v());
      ds.field("repeat_w", &self.repeat_w());
      ds.field("border_color", &self.border_color());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SamplerStateT {
  pub SamplerState_0: u32,
  pub SamplerState_1: u32,
  pub SamplerState_2: u32,
  pub SamplerState_3: u32,
  pub SamplerState_4: u32,
  pub SamplerState_5: u32,
  pub SamplerState_6: u32,
  pub SamplerState_7: u32,
  pub SamplerState_8: u32,
  pub repeat_u: UVWrapMode,
  pub repeat_v: UVWrapMode,
  pub repeat_w: UVWrapMode,
  pub border_color: Option<RGBAT>,
}
impl Default for SamplerStateT {
  fn default() -> Self {
    Self {
      SamplerState_0: 0,
      SamplerState_1: 0,
      SamplerState_2: 0,
      SamplerState_3: 0,
      SamplerState_4: 0,
      SamplerState_5: 0,
      SamplerState_6: 0,
      SamplerState_7: 0,
      SamplerState_8: 0,
      repeat_u: UVWrapMode::WRAP,
      repeat_v: UVWrapMode::WRAP,
      repeat_w: UVWrapMode::WRAP,
      border_color: None,
    }
  }
}
impl SamplerStateT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SamplerState<'b>> {
    let SamplerState_0 = self.SamplerState_0;
    let SamplerState_1 = self.SamplerState_1;
    let SamplerState_2 = self.SamplerState_2;
    let SamplerState_3 = self.SamplerState_3;
    let SamplerState_4 = self.SamplerState_4;
    let SamplerState_5 = self.SamplerState_5;
    let SamplerState_6 = self.SamplerState_6;
    let SamplerState_7 = self.SamplerState_7;
    let SamplerState_8 = self.SamplerState_8;
    let repeat_u = self.repeat_u;
    let repeat_v = self.repeat_v;
    let repeat_w = self.repeat_w;
    let border_color_tmp = self.border_color.as_ref().map(|x| x.pack());
    let border_color = border_color_tmp.as_ref();
    SamplerState::create(_fbb, &SamplerStateArgs{
      SamplerState_0,
      SamplerState_1,
      SamplerState_2,
      SamplerState_3,
      SamplerState_4,
      SamplerState_5,
      SamplerState_6,
      SamplerState_7,
      SamplerState_8,
      repeat_u,
      repeat_v,
      repeat_w,
      border_color,
    })
  }
}
pub enum Float4ParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float4Parameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float4Parameter<'a> {
  type Inner = Float4Parameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Float4Parameter<'a> {
  pub const VT_COLOR_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Float4Parameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Float4ParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<Float4Parameter<'bldr>> {
    let mut builder = Float4ParameterBuilder::new(_fbb);
    if let Some(x) = args.color_value { builder.add_color_value(x); }
    if let Some(x) = args.color_name { builder.add_color_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Float4ParameterT {
    let color_name = self.color_name().map(|x| {
      x.to_string()
    });
    let color_value = self.color_value().map(|x| {
      x.unpack()
    });
    Float4ParameterT {
      color_name,
      color_value,
    }
  }

  #[inline]
  pub fn color_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Float4Parameter::VT_COLOR_NAME, None)}
  }
  #[inline]
  pub fn color_value(&self) -> Option<&'a RGBA> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RGBA>(Float4Parameter::VT_COLOR_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Float4Parameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color_name", Self::VT_COLOR_NAME, false)?
     .visit_field::<RGBA>("color_value", Self::VT_COLOR_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Float4ParameterArgs<'a> {
    pub color_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color_value: Option<&'a RGBA>,
}
impl<'a> Default for Float4ParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    Float4ParameterArgs {
      color_name: None,
      color_value: None,
    }
  }
}

pub struct Float4ParameterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Float4ParameterBuilder<'a, 'b> {
  #[inline]
  pub fn add_color_name(&mut self, color_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Float4Parameter::VT_COLOR_NAME, color_name);
  }
  #[inline]
  pub fn add_color_value(&mut self, color_value: &RGBA) {
    self.fbb_.push_slot_always::<&RGBA>(Float4Parameter::VT_COLOR_VALUE, color_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Float4ParameterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Float4ParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float4Parameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Float4Parameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Float4Parameter");
      ds.field("color_name", &self.color_name());
      ds.field("color_value", &self.color_value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Float4ParameterT {
  pub color_name: Option<String>,
  pub color_value: Option<RGBAT>,
}
impl Default for Float4ParameterT {
  fn default() -> Self {
    Self {
      color_name: None,
      color_value: None,
    }
  }
}
impl Float4ParameterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Float4Parameter<'b>> {
    let color_name = self.color_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let color_value_tmp = self.color_value.as_ref().map(|x| x.pack());
    let color_value = color_value_tmp.as_ref();
    Float4Parameter::create(_fbb, &Float4ParameterArgs{
      color_name,
      color_value,
    })
  }
}
pub enum FloatParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatParameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatParameter<'a> {
  type Inner = FloatParameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloatParameter<'a> {
  pub const VT_FLOAT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_FLOAT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloatParameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FloatParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<FloatParameter<'bldr>> {
    let mut builder = FloatParameterBuilder::new(_fbb);
    builder.add_float_value(args.float_value);
    if let Some(x) = args.float_name { builder.add_float_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> FloatParameterT {
    let float_name = self.float_name().map(|x| {
      x.to_string()
    });
    let float_value = self.float_value();
    FloatParameterT {
      float_name,
      float_value,
    }
  }

  #[inline]
  pub fn float_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatParameter::VT_FLOAT_NAME, None)}
  }
  #[inline]
  pub fn float_value(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FloatParameter::VT_FLOAT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FloatParameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("float_name", Self::VT_FLOAT_NAME, false)?
     .visit_field::<f32>("float_value", Self::VT_FLOAT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatParameterArgs<'a> {
    pub float_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub float_value: f32,
}
impl<'a> Default for FloatParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    FloatParameterArgs {
      float_name: None,
      float_value: 0.0,
    }
  }
}

pub struct FloatParameterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatParameterBuilder<'a, 'b> {
  #[inline]
  pub fn add_float_name(&mut self, float_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatParameter::VT_FLOAT_NAME, float_name);
  }
  #[inline]
  pub fn add_float_value(&mut self, float_value: f32) {
    self.fbb_.push_slot::<f32>(FloatParameter::VT_FLOAT_VALUE, float_value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatParameterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloatParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloatParameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloatParameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloatParameter");
      ds.field("float_name", &self.float_name());
      ds.field("float_value", &self.float_value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FloatParameterT {
  pub float_name: Option<String>,
  pub float_value: f32,
}
impl Default for FloatParameterT {
  fn default() -> Self {
    Self {
      float_name: None,
      float_value: 0.0,
    }
  }
}
impl FloatParameterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<FloatParameter<'b>> {
    let float_name = self.float_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let float_value = self.float_value;
    FloatParameter::create(_fbb, &FloatParameterArgs{
      float_name,
      float_value,
    })
  }
}
pub enum IntParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntParameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntParameter<'a> {
  type Inner = IntParameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntParameter<'a> {
  pub const VT_INT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_INT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntParameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IntParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<IntParameter<'bldr>> {
    let mut builder = IntParameterBuilder::new(_fbb);
    builder.add_int_value(args.int_value);
    if let Some(x) = args.int_name { builder.add_int_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> IntParameterT {
    let int_name = self.int_name().map(|x| {
      x.to_string()
    });
    let int_value = self.int_value();
    IntParameterT {
      int_name,
      int_value,
    }
  }

  #[inline]
  pub fn int_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntParameter::VT_INT_NAME, None)}
  }
  #[inline]
  pub fn int_value(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(IntParameter::VT_INT_VALUE, Some(-1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IntParameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("int_name", Self::VT_INT_NAME, false)?
     .visit_field::<i32>("int_value", Self::VT_INT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntParameterArgs<'a> {
    pub int_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub int_value: i32,
}
impl<'a> Default for IntParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntParameterArgs {
      int_name: None,
      int_value: -1,
    }
  }
}

pub struct IntParameterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntParameterBuilder<'a, 'b> {
  #[inline]
  pub fn add_int_name(&mut self, int_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntParameter::VT_INT_NAME, int_name);
  }
  #[inline]
  pub fn add_int_value(&mut self, int_value: i32) {
    self.fbb_.push_slot::<i32>(IntParameter::VT_INT_VALUE, int_value, -1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntParameterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntParameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntParameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntParameter");
      ds.field("int_name", &self.int_name());
      ds.field("int_value", &self.int_value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IntParameterT {
  pub int_name: Option<String>,
  pub int_value: i32,
}
impl Default for IntParameterT {
  fn default() -> Self {
    Self {
      int_name: None,
      int_value: -1,
    }
  }
}
impl IntParameterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<IntParameter<'b>> {
    let int_name = self.int_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let int_value = self.int_value;
    IntParameter::create(_fbb, &IntParameterArgs{
      int_name,
      int_value,
    })
  }
}
pub enum StringParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringParameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringParameter<'a> {
  type Inner = StringParameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringParameter<'a> {
  pub const VT_STRING_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_STRING_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringParameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StringParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<StringParameter<'bldr>> {
    let mut builder = StringParameterBuilder::new(_fbb);
    if let Some(x) = args.string_value { builder.add_string_value(x); }
    if let Some(x) = args.string_name { builder.add_string_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StringParameterT {
    let string_name = self.string_name().map(|x| {
      x.to_string()
    });
    let string_value = self.string_value().map(|x| {
      x.to_string()
    });
    StringParameterT {
      string_name,
      string_value,
    }
  }

  #[inline]
  pub fn string_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameter::VT_STRING_NAME, None)}
  }
  #[inline]
  pub fn string_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameter::VT_STRING_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for StringParameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("string_name", Self::VT_STRING_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("string_value", Self::VT_STRING_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct StringParameterArgs<'a> {
    pub string_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub string_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringParameterArgs {
      string_name: None,
      string_value: None,
    }
  }
}

pub struct StringParameterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StringParameterBuilder<'a, 'b> {
  #[inline]
  pub fn add_string_name(&mut self, string_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameter::VT_STRING_NAME, string_name);
  }
  #[inline]
  pub fn add_string_value(&mut self, string_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameter::VT_STRING_VALUE, string_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StringParameterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StringParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringParameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringParameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringParameter");
      ds.field("string_name", &self.string_name());
      ds.field("string_value", &self.string_value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StringParameterT {
  pub string_name: Option<String>,
  pub string_value: Option<String>,
}
impl Default for StringParameterT {
  fn default() -> Self {
    Self {
      string_name: None,
      string_value: None,
    }
  }
}
impl StringParameterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<StringParameter<'b>> {
    let string_name = self.string_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let string_value = self.string_value.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    StringParameter::create(_fbb, &StringParameterArgs{
      string_name,
      string_value,
    })
  }
}
pub enum ShaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Shader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Shader<'a> {
  type Inner = Shader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Shader<'a> {
  pub const VT_SHADER_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHADER_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Shader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShaderArgs<'args>
  ) -> flatbuffers::WIPOffset<Shader<'bldr>> {
    let mut builder = ShaderBuilder::new(_fbb);
    if let Some(x) = args.shader_values { builder.add_shader_values(x); }
    if let Some(x) = args.shader_name { builder.add_shader_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ShaderT {
    let shader_name = self.shader_name().map(|x| {
      x.to_string()
    });
    let shader_values = self.shader_values().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ShaderT {
      shader_name,
      shader_values,
    }
  }

  #[inline]
  pub fn shader_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Shader::VT_SHADER_NAME, None)}
  }
  #[inline]
  pub fn shader_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringParameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringParameter>>>>(Shader::VT_SHADER_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for Shader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shader_name", Self::VT_SHADER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringParameter>>>>("shader_values", Self::VT_SHADER_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct ShaderArgs<'a> {
    pub shader_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shader_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringParameter<'a>>>>>,
}
impl<'a> Default for ShaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShaderArgs {
      shader_name: None,
      shader_values: None,
    }
  }
}

pub struct ShaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_shader_name(&mut self, shader_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shader::VT_SHADER_NAME, shader_name);
  }
  #[inline]
  pub fn add_shader_values(&mut self, shader_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringParameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shader::VT_SHADER_VALUES, shader_values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Shader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Shader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Shader");
      ds.field("shader_name", &self.shader_name());
      ds.field("shader_values", &self.shader_values());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ShaderT {
  pub shader_name: Option<String>,
  pub shader_values: Option<Vec<StringParameterT>>,
}
impl Default for ShaderT {
  fn default() -> Self {
    Self {
      shader_name: None,
      shader_values: None,
    }
  }
}
impl ShaderT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Shader<'b>> {
    let shader_name = self.shader_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let shader_values = self.shader_values.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Shader::create(_fbb, &ShaderArgs{
      shader_name,
      shader_values,
    })
  }
}
pub enum TextureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Texture<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Texture<'a> {
  type Inner = Texture<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Texture<'a> {
  pub const VT_TEXTURE_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TEXTURE_FILE: flatbuffers::VOffsetT = 6;
  pub const VT_TEXTURE_SLOT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Texture { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TextureArgs<'args>
  ) -> flatbuffers::WIPOffset<Texture<'bldr>> {
    let mut builder = TextureBuilder::new(_fbb);
    builder.add_texture_slot(args.texture_slot);
    if let Some(x) = args.texture_file { builder.add_texture_file(x); }
    if let Some(x) = args.texture_name { builder.add_texture_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TextureT {
    let texture_name = self.texture_name().map(|x| {
      x.to_string()
    });
    let texture_file = self.texture_file().map(|x| {
      x.to_string()
    });
    let texture_slot = self.texture_slot();
    TextureT {
      texture_name,
      texture_file,
      texture_slot,
    }
  }

  #[inline]
  pub fn texture_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Texture::VT_TEXTURE_NAME, None)}
  }
  #[inline]
  pub fn texture_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Texture::VT_TEXTURE_FILE, None)}
  }
  #[inline]
  pub fn texture_slot(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Texture::VT_TEXTURE_SLOT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Texture<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("texture_name", Self::VT_TEXTURE_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("texture_file", Self::VT_TEXTURE_FILE, false)?
     .visit_field::<u32>("texture_slot", Self::VT_TEXTURE_SLOT, false)?
     .finish();
    Ok(())
  }
}
pub struct TextureArgs<'a> {
    pub texture_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub texture_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub texture_slot: u32,
}
impl<'a> Default for TextureArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextureArgs {
      texture_name: None,
      texture_file: None,
      texture_slot: 0,
    }
  }
}

pub struct TextureBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TextureBuilder<'a, 'b> {
  #[inline]
  pub fn add_texture_name(&mut self, texture_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Texture::VT_TEXTURE_NAME, texture_name);
  }
  #[inline]
  pub fn add_texture_file(&mut self, texture_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Texture::VT_TEXTURE_FILE, texture_file);
  }
  #[inline]
  pub fn add_texture_slot(&mut self, texture_slot: u32) {
    self.fbb_.push_slot::<u32>(Texture::VT_TEXTURE_SLOT, texture_slot, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TextureBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TextureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Texture<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Texture<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Texture");
      ds.field("texture_name", &self.texture_name());
      ds.field("texture_file", &self.texture_file());
      ds.field("texture_slot", &self.texture_slot());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TextureT {
  pub texture_name: Option<String>,
  pub texture_file: Option<String>,
  pub texture_slot: u32,
}
impl Default for TextureT {
  fn default() -> Self {
    Self {
      texture_name: None,
      texture_file: None,
      texture_slot: 0,
    }
  }
}
impl TextureT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Texture<'b>> {
    let texture_name = self.texture_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let texture_file = self.texture_file.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let texture_slot = self.texture_slot;
    Texture::create(_fbb, &TextureArgs{
      texture_name,
      texture_file,
      texture_slot,
    })
  }
}
pub enum Byte_ExtraOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Byte_Extra<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Byte_Extra<'a> {
  type Inner = Byte_Extra<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Byte_Extra<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Byte_Extra { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Byte_ExtraArgs
  ) -> flatbuffers::WIPOffset<Byte_Extra<'bldr>> {
    let mut builder = Byte_ExtraBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }

  pub fn unpack(&self) -> Byte_ExtraT {
    let value = self.value();
    Byte_ExtraT {
      value,
    }
  }

  #[inline]
  pub fn value(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Byte_Extra::VT_VALUE, Some(-1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Byte_Extra<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Byte_ExtraArgs {
    pub value: i8,
}
impl<'a> Default for Byte_ExtraArgs {
  #[inline]
  fn default() -> Self {
    Byte_ExtraArgs {
      value: -1,
    }
  }
}

pub struct Byte_ExtraBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Byte_ExtraBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: i8) {
    self.fbb_.push_slot::<i8>(Byte_Extra::VT_VALUE, value, -1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Byte_ExtraBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Byte_ExtraBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Byte_Extra<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Byte_Extra<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Byte_Extra");
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Byte_ExtraT {
  pub value: i8,
}
impl Default for Byte_ExtraT {
  fn default() -> Self {
    Self {
      value: -1,
    }
  }
}
impl Byte_ExtraT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Byte_Extra<'b>> {
    let value = self.value;
    Byte_Extra::create(_fbb, &Byte_ExtraArgs{
      value,
    })
  }
}
pub enum Int_ExtraOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int_Extra<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int_Extra<'a> {
  type Inner = Int_Extra<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Int_Extra<'a> {
  pub const VT_RES_0: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Int_Extra { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Int_ExtraArgs
  ) -> flatbuffers::WIPOffset<Int_Extra<'bldr>> {
    let mut builder = Int_ExtraBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.add_res_0(args.res_0);
    builder.finish()
  }

  pub fn unpack(&self) -> Int_ExtraT {
    let res_0 = self.res_0();
    let value = self.value();
    Int_ExtraT {
      res_0,
      value,
    }
  }

  #[inline]
  pub fn res_0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Int_Extra::VT_RES_0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Int_Extra::VT_VALUE, Some(-1)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Int_Extra<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("res_0", Self::VT_RES_0, false)?
     .visit_field::<i32>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct Int_ExtraArgs {
    pub res_0: u32,
    pub value: i32,
}
impl<'a> Default for Int_ExtraArgs {
  #[inline]
  fn default() -> Self {
    Int_ExtraArgs {
      res_0: 0,
      value: -1,
    }
  }
}

pub struct Int_ExtraBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Int_ExtraBuilder<'a, 'b> {
  #[inline]
  pub fn add_res_0(&mut self, res_0: u32) {
    self.fbb_.push_slot::<u32>(Int_Extra::VT_RES_0, res_0, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: i32) {
    self.fbb_.push_slot::<i32>(Int_Extra::VT_VALUE, value, -1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int_ExtraBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Int_ExtraBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int_Extra<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Int_Extra<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Int_Extra");
      ds.field("res_0", &self.res_0());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Int_ExtraT {
  pub res_0: u32,
  pub value: i32,
}
impl Default for Int_ExtraT {
  fn default() -> Self {
    Self {
      res_0: 0,
      value: -1,
    }
  }
}
impl Int_ExtraT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Int_Extra<'b>> {
    let res_0 = self.res_0;
    let value = self.value;
    Int_Extra::create(_fbb, &Int_ExtraArgs{
      res_0,
      value,
    })
  }
}
pub enum MaterialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Material<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Material<'a> {
  type Inner = Material<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Material<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHADERS: flatbuffers::VOffsetT = 6;
  pub const VT_TEXTURES: flatbuffers::VOffsetT = 8;
  pub const VT_SAMPLERS: flatbuffers::VOffsetT = 10;
  pub const VT_FLOAT_PARAMETER: flatbuffers::VOffsetT = 12;
  pub const VT_UNK_5: flatbuffers::VOffsetT = 14;
  pub const VT_FLOAT4_LIGHT_PARAMETER: flatbuffers::VOffsetT = 16;
  pub const VT_FLOAT4_PARAMETER: flatbuffers::VOffsetT = 18;
  pub const VT_UNK_8: flatbuffers::VOffsetT = 20;
  pub const VT_INT_PARAMETER: flatbuffers::VOffsetT = 22;
  pub const VT_UNK_10: flatbuffers::VOffsetT = 24;
  pub const VT_UNK_11: flatbuffers::VOffsetT = 26;
  pub const VT_UNK_12: flatbuffers::VOffsetT = 28;
  pub const VT_BYTE_EXTRA: flatbuffers::VOffsetT = 30;
  pub const VT_INT_EXTRA: flatbuffers::VOffsetT = 32;
  pub const VT_ALPHA_TYPE: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Material { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MaterialArgs<'args>
  ) -> flatbuffers::WIPOffset<Material<'bldr>> {
    let mut builder = MaterialBuilder::new(_fbb);
    if let Some(x) = args.alpha_type { builder.add_alpha_type(x); }
    if let Some(x) = args.int_extra { builder.add_int_extra(x); }
    if let Some(x) = args.byte_extra { builder.add_byte_extra(x); }
    if let Some(x) = args.unk_12 { builder.add_unk_12(x); }
    if let Some(x) = args.unk_11 { builder.add_unk_11(x); }
    if let Some(x) = args.unk_10 { builder.add_unk_10(x); }
    if let Some(x) = args.int_parameter { builder.add_int_parameter(x); }
    if let Some(x) = args.unk_8 { builder.add_unk_8(x); }
    if let Some(x) = args.float4_parameter { builder.add_float4_parameter(x); }
    if let Some(x) = args.float4_light_parameter { builder.add_float4_light_parameter(x); }
    if let Some(x) = args.unk_5 { builder.add_unk_5(x); }
    if let Some(x) = args.float_parameter { builder.add_float_parameter(x); }
    if let Some(x) = args.samplers { builder.add_samplers(x); }
    if let Some(x) = args.textures { builder.add_textures(x); }
    if let Some(x) = args.shaders { builder.add_shaders(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MaterialT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let shaders = self.shaders().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let textures = self.textures().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let samplers = self.samplers().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let float_parameter = self.float_parameter().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let unk_5 = self.unk_5().map(|x| {
      x.to_string()
    });
    let float4_light_parameter = self.float4_light_parameter().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let float4_parameter = self.float4_parameter().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let unk_8 = self.unk_8().map(|x| {
      x.to_string()
    });
    let int_parameter = self.int_parameter().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let unk_10 = self.unk_10().map(|x| {
      x.to_string()
    });
    let unk_11 = self.unk_11().map(|x| {
      x.to_string()
    });
    let unk_12 = self.unk_12().map(|x| {
      x.to_string()
    });
    let byte_extra = self.byte_extra().map(|x| {
      Box::new(x.unpack())
    });
    let int_extra = self.int_extra().map(|x| {
      Box::new(x.unpack())
    });
    let alpha_type = self.alpha_type().map(|x| {
      x.to_string()
    });
    MaterialT {
      name,
      shaders,
      textures,
      samplers,
      float_parameter,
      unk_5,
      float4_light_parameter,
      float4_parameter,
      unk_8,
      int_parameter,
      unk_10,
      unk_11,
      unk_12,
      byte_extra,
      int_extra,
      alpha_type,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_NAME, None)}
  }
  #[inline]
  pub fn shaders(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Shader<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Shader>>>>(Material::VT_SHADERS, None)}
  }
  #[inline]
  pub fn textures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture>>>>(Material::VT_TEXTURES, None)}
  }
  #[inline]
  pub fn samplers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SamplerState<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SamplerState>>>>(Material::VT_SAMPLERS, None)}
  }
  #[inline]
  pub fn float_parameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatParameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatParameter>>>>(Material::VT_FLOAT_PARAMETER, None)}
  }
  #[inline]
  pub fn unk_5(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_UNK_5, None)}
  }
  #[inline]
  pub fn float4_light_parameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float4Parameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float4Parameter>>>>(Material::VT_FLOAT4_LIGHT_PARAMETER, None)}
  }
  #[inline]
  pub fn float4_parameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float4Parameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float4Parameter>>>>(Material::VT_FLOAT4_PARAMETER, None)}
  }
  #[inline]
  pub fn unk_8(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_UNK_8, None)}
  }
  #[inline]
  pub fn int_parameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntParameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntParameter>>>>(Material::VT_INT_PARAMETER, None)}
  }
  #[inline]
  pub fn unk_10(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_UNK_10, None)}
  }
  #[inline]
  pub fn unk_11(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_UNK_11, None)}
  }
  #[inline]
  pub fn unk_12(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_UNK_12, None)}
  }
  #[inline]
  pub fn byte_extra(&self) -> Option<Byte_Extra<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Byte_Extra>>(Material::VT_BYTE_EXTRA, None)}
  }
  #[inline]
  pub fn int_extra(&self) -> Option<Int_Extra<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Int_Extra>>(Material::VT_INT_EXTRA, None)}
  }
  #[inline]
  pub fn alpha_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_ALPHA_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for Material<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Shader>>>>("shaders", Self::VT_SHADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Texture>>>>("textures", Self::VT_TEXTURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SamplerState>>>>("samplers", Self::VT_SAMPLERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FloatParameter>>>>("float_parameter", Self::VT_FLOAT_PARAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_5", Self::VT_UNK_5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Float4Parameter>>>>("float4_light_parameter", Self::VT_FLOAT4_LIGHT_PARAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Float4Parameter>>>>("float4_parameter", Self::VT_FLOAT4_PARAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_8", Self::VT_UNK_8, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntParameter>>>>("int_parameter", Self::VT_INT_PARAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_10", Self::VT_UNK_10, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_11", Self::VT_UNK_11, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_12", Self::VT_UNK_12, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Byte_Extra>>("byte_extra", Self::VT_BYTE_EXTRA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Int_Extra>>("int_extra", Self::VT_INT_EXTRA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alpha_type", Self::VT_ALPHA_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct MaterialArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shaders: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Shader<'a>>>>>,
    pub textures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture<'a>>>>>,
    pub samplers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SamplerState<'a>>>>>,
    pub float_parameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatParameter<'a>>>>>,
    pub unk_5: Option<flatbuffers::WIPOffset<&'a str>>,
    pub float4_light_parameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float4Parameter<'a>>>>>,
    pub float4_parameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Float4Parameter<'a>>>>>,
    pub unk_8: Option<flatbuffers::WIPOffset<&'a str>>,
    pub int_parameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntParameter<'a>>>>>,
    pub unk_10: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_11: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_12: Option<flatbuffers::WIPOffset<&'a str>>,
    pub byte_extra: Option<flatbuffers::WIPOffset<Byte_Extra<'a>>>,
    pub int_extra: Option<flatbuffers::WIPOffset<Int_Extra<'a>>>,
    pub alpha_type: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MaterialArgs<'a> {
  #[inline]
  fn default() -> Self {
    MaterialArgs {
      name: None,
      shaders: None,
      textures: None,
      samplers: None,
      float_parameter: None,
      unk_5: None,
      float4_light_parameter: None,
      float4_parameter: None,
      unk_8: None,
      int_parameter: None,
      unk_10: None,
      unk_11: None,
      unk_12: None,
      byte_extra: None,
      int_extra: None,
      alpha_type: None,
    }
  }
}

pub struct MaterialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaterialBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_NAME, name);
  }
  #[inline]
  pub fn add_shaders(&mut self, shaders: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Shader<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_SHADERS, shaders);
  }
  #[inline]
  pub fn add_textures(&mut self, textures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Texture<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_TEXTURES, textures);
  }
  #[inline]
  pub fn add_samplers(&mut self, samplers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SamplerState<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_SAMPLERS, samplers);
  }
  #[inline]
  pub fn add_float_parameter(&mut self, float_parameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FloatParameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_FLOAT_PARAMETER, float_parameter);
  }
  #[inline]
  pub fn add_unk_5(&mut self, unk_5: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_UNK_5, unk_5);
  }
  #[inline]
  pub fn add_float4_light_parameter(&mut self, float4_light_parameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Float4Parameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_FLOAT4_LIGHT_PARAMETER, float4_light_parameter);
  }
  #[inline]
  pub fn add_float4_parameter(&mut self, float4_parameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Float4Parameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_FLOAT4_PARAMETER, float4_parameter);
  }
  #[inline]
  pub fn add_unk_8(&mut self, unk_8: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_UNK_8, unk_8);
  }
  #[inline]
  pub fn add_int_parameter(&mut self, int_parameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntParameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_INT_PARAMETER, int_parameter);
  }
  #[inline]
  pub fn add_unk_10(&mut self, unk_10: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_UNK_10, unk_10);
  }
  #[inline]
  pub fn add_unk_11(&mut self, unk_11: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_UNK_11, unk_11);
  }
  #[inline]
  pub fn add_unk_12(&mut self, unk_12: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_UNK_12, unk_12);
  }
  #[inline]
  pub fn add_byte_extra(&mut self, byte_extra: flatbuffers::WIPOffset<Byte_Extra<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Byte_Extra>>(Material::VT_BYTE_EXTRA, byte_extra);
  }
  #[inline]
  pub fn add_int_extra(&mut self, int_extra: flatbuffers::WIPOffset<Int_Extra<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int_Extra>>(Material::VT_INT_EXTRA, int_extra);
  }
  #[inline]
  pub fn add_alpha_type(&mut self, alpha_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_ALPHA_TYPE, alpha_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaterialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MaterialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Material<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Material<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Material");
      ds.field("name", &self.name());
      ds.field("shaders", &self.shaders());
      ds.field("textures", &self.textures());
      ds.field("samplers", &self.samplers());
      ds.field("float_parameter", &self.float_parameter());
      ds.field("unk_5", &self.unk_5());
      ds.field("float4_light_parameter", &self.float4_light_parameter());
      ds.field("float4_parameter", &self.float4_parameter());
      ds.field("unk_8", &self.unk_8());
      ds.field("int_parameter", &self.int_parameter());
      ds.field("unk_10", &self.unk_10());
      ds.field("unk_11", &self.unk_11());
      ds.field("unk_12", &self.unk_12());
      ds.field("byte_extra", &self.byte_extra());
      ds.field("int_extra", &self.int_extra());
      ds.field("alpha_type", &self.alpha_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MaterialT {
  pub name: Option<String>,
  pub shaders: Option<Vec<ShaderT>>,
  pub textures: Option<Vec<TextureT>>,
  pub samplers: Option<Vec<SamplerStateT>>,
  pub float_parameter: Option<Vec<FloatParameterT>>,
  pub unk_5: Option<String>,
  pub float4_light_parameter: Option<Vec<Float4ParameterT>>,
  pub float4_parameter: Option<Vec<Float4ParameterT>>,
  pub unk_8: Option<String>,
  pub int_parameter: Option<Vec<IntParameterT>>,
  pub unk_10: Option<String>,
  pub unk_11: Option<String>,
  pub unk_12: Option<String>,
  pub byte_extra: Option<Box<Byte_ExtraT>>,
  pub int_extra: Option<Box<Int_ExtraT>>,
  pub alpha_type: Option<String>,
}
impl Default for MaterialT {
  fn default() -> Self {
    Self {
      name: None,
      shaders: None,
      textures: None,
      samplers: None,
      float_parameter: None,
      unk_5: None,
      float4_light_parameter: None,
      float4_parameter: None,
      unk_8: None,
      int_parameter: None,
      unk_10: None,
      unk_11: None,
      unk_12: None,
      byte_extra: None,
      int_extra: None,
      alpha_type: None,
    }
  }
}
impl MaterialT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Material<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let shaders = self.shaders.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let textures = self.textures.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let samplers = self.samplers.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let float_parameter = self.float_parameter.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let unk_5 = self.unk_5.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let float4_light_parameter = self.float4_light_parameter.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let float4_parameter = self.float4_parameter.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let unk_8 = self.unk_8.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let int_parameter = self.int_parameter.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let unk_10 = self.unk_10.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let unk_11 = self.unk_11.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let unk_12 = self.unk_12.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let byte_extra = self.byte_extra.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let int_extra = self.int_extra.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let alpha_type = self.alpha_type.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Material::create(_fbb, &MaterialArgs{
      name,
      shaders,
      textures,
      samplers,
      float_parameter,
      unk_5,
      float4_light_parameter,
      float4_parameter,
      unk_8,
      int_parameter,
      unk_10,
      unk_11,
      unk_12,
      byte_extra,
      int_extra,
      alpha_type,
    })
  }
}
pub enum TRMTROffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TRMTR<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TRMTR<'a> {
  type Inner = TRMTR<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TRMTR<'a> {
  pub const VT_RES_0: flatbuffers::VOffsetT = 4;
  pub const VT_MATERIALS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TRMTR { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TRMTRArgs<'args>
  ) -> flatbuffers::WIPOffset<TRMTR<'bldr>> {
    let mut builder = TRMTRBuilder::new(_fbb);
    if let Some(x) = args.materials { builder.add_materials(x); }
    builder.add_res_0(args.res_0);
    builder.finish()
  }

  pub fn unpack(&self) -> TRMTRT {
    let res_0 = self.res_0();
    let materials = self.materials().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    TRMTRT {
      res_0,
      materials,
    }
  }

  #[inline]
  pub fn res_0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TRMTR::VT_RES_0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn materials(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material>>>>(TRMTR::VT_MATERIALS, None)}
  }
}

impl flatbuffers::Verifiable for TRMTR<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("res_0", Self::VT_RES_0, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Material>>>>("materials", Self::VT_MATERIALS, false)?
     .finish();
    Ok(())
  }
}
pub struct TRMTRArgs<'a> {
    pub res_0: u32,
    pub materials: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material<'a>>>>>,
}
impl<'a> Default for TRMTRArgs<'a> {
  #[inline]
  fn default() -> Self {
    TRMTRArgs {
      res_0: 0,
      materials: None,
    }
  }
}

pub struct TRMTRBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TRMTRBuilder<'a, 'b> {
  #[inline]
  pub fn add_res_0(&mut self, res_0: u32) {
    self.fbb_.push_slot::<u32>(TRMTR::VT_RES_0, res_0, 0);
  }
  #[inline]
  pub fn add_materials(&mut self, materials: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Material<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRMTR::VT_MATERIALS, materials);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRMTRBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TRMTRBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TRMTR<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TRMTR<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TRMTR");
      ds.field("res_0", &self.res_0());
      ds.field("materials", &self.materials());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TRMTRT {
  pub res_0: u32,
  pub materials: Option<Vec<MaterialT>>,
}
impl Default for TRMTRT {
  fn default() -> Self {
    Self {
      res_0: 0,
      materials: None,
    }
  }
}
impl TRMTRT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TRMTR<'b>> {
    let res_0 = self.res_0;
    let materials = self.materials.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    TRMTR::create(_fbb, &TRMTRArgs{
      res_0,
      materials,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TRMTR`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trmtr_unchecked`.
pub fn root_as_trmtr(buf: &[u8]) -> Result<TRMTR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TRMTR>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TRMTR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_trmtr_unchecked`.
pub fn size_prefixed_root_as_trmtr(buf: &[u8]) -> Result<TRMTR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TRMTR>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TRMTR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trmtr_unchecked`.
pub fn root_as_trmtr_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRMTR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TRMTR<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TRMTR` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trmtr_unchecked`.
pub fn size_prefixed_root_as_trmtr_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRMTR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TRMTR<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TRMTR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TRMTR`.
pub unsafe fn root_as_trmtr_unchecked(buf: &[u8]) -> TRMTR {
  flatbuffers::root_unchecked::<TRMTR>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TRMTR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TRMTR`.
pub unsafe fn size_prefixed_root_as_trmtr_unchecked(buf: &[u8]) -> TRMTR {
  flatbuffers::size_prefixed_root_unchecked::<TRMTR>(buf)
}
pub const TRMTR_EXTENSION: &str = "trmtr";

#[inline]
pub fn finish_trmtr_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<TRMTR<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_trmtr_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<TRMTR<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Model
}  // pub mod Titan

