// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod model {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum UnkEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnkEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnkEntry<'a> {
  type Inner = UnkEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnkEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnkEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnkEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<UnkEntry<'bldr>> {
    let mut builder = UnkEntryBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> UnkEntryT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    UnkEntryT {
      name,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UnkEntry::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for UnkEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct UnkEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UnkEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnkEntryArgs {
      name: None,
    }
  }
}

pub struct UnkEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnkEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnkEntry::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnkEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnkEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnkEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnkEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnkEntry");
      ds.field("name", &self.name());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UnkEntryT {
  pub name: Option<String>,
}
impl Default for UnkEntryT {
  fn default() -> Self {
    Self {
      name: None,
    }
  }
}
impl UnkEntryT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<UnkEntry<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    UnkEntry::create(_fbb, &UnkEntryArgs{
      name,
    })
  }
}
pub enum BoneEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoneEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoneEntry<'a> {
  type Inner = BoneEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoneEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SLOTS: flatbuffers::VOffsetT = 6;
  pub const VT_UNK_3: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoneEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoneEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BoneEntry<'bldr>> {
    let mut builder = BoneEntryBuilder::new(_fbb);
    builder.add_unk_3(args.unk_3);
    if let Some(x) = args.slots { builder.add_slots(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BoneEntryT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let slots = self.slots().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let unk_3 = self.unk_3();
    BoneEntryT {
      name,
      slots,
      unk_3,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoneEntry::VT_NAME, None)}
  }
  #[inline]
  pub fn slots(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(BoneEntry::VT_SLOTS, None)}
  }
  #[inline]
  pub fn unk_3(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BoneEntry::VT_UNK_3, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoneEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("slots", Self::VT_SLOTS, false)?
     .visit_field::<f32>("unk_3", Self::VT_UNK_3, false)?
     .finish();
    Ok(())
  }
}
pub struct BoneEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slots: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub unk_3: f32,
}
impl<'a> Default for BoneEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoneEntryArgs {
      name: None,
      slots: None,
      unk_3: 0.0,
    }
  }
}

pub struct BoneEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoneEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoneEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_slots(&mut self, slots: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoneEntry::VT_SLOTS, slots);
  }
  #[inline]
  pub fn add_unk_3(&mut self, unk_3: f32) {
    self.fbb_.push_slot::<f32>(BoneEntry::VT_UNK_3, unk_3, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoneEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoneEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoneEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoneEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoneEntry");
      ds.field("name", &self.name());
      ds.field("slots", &self.slots());
      ds.field("unk_3", &self.unk_3());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BoneEntryT {
  pub name: Option<String>,
  pub slots: Option<Vec<String>>,
  pub unk_3: f32,
}
impl Default for BoneEntryT {
  fn default() -> Self {
    Self {
      name: None,
      slots: None,
      unk_3: 0.0,
    }
  }
}
impl BoneEntryT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<BoneEntry<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let slots = self.slots.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let unk_3 = self.unk_3;
    BoneEntry::create(_fbb, &BoneEntryArgs{
      name,
      slots,
      unk_3,
    })
  }
}
pub enum ScalerEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScalerEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScalerEntry<'a> {
  type Inner = ScalerEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScalerEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SLOT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_UNK_3: flatbuffers::VOffsetT = 8;
  pub const VT_UNK_4: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScalerEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ScalerEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ScalerEntry<'bldr>> {
    let mut builder = ScalerEntryBuilder::new(_fbb);
    if let Some(x) = args.unk_4 { builder.add_unk_4(x); }
    if let Some(x) = args.slot_name { builder.add_slot_name(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_unk_3(args.unk_3);
    builder.finish()
  }

  pub fn unpack(&self) -> ScalerEntryT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let slot_name = self.slot_name().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let unk_3 = self.unk_3();
    let unk_4 = self.unk_4().map(|x| {
      x.into_iter().collect()
    });
    ScalerEntryT {
      name,
      slot_name,
      unk_3,
      unk_4,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScalerEntry::VT_NAME, None)}
  }
  #[inline]
  pub fn slot_name(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ScalerEntry::VT_SLOT_NAME, None)}
  }
  #[inline]
  pub fn unk_3(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ScalerEntry::VT_UNK_3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk_4(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ScalerEntry::VT_UNK_4, None)}
  }
}

impl flatbuffers::Verifiable for ScalerEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("slot_name", Self::VT_SLOT_NAME, false)?
     .visit_field::<u8>("unk_3", Self::VT_UNK_3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("unk_4", Self::VT_UNK_4, false)?
     .finish();
    Ok(())
  }
}
pub struct ScalerEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slot_name: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub unk_3: u8,
    pub unk_4: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for ScalerEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScalerEntryArgs {
      name: None,
      slot_name: None,
      unk_3: 0,
      unk_4: None,
    }
  }
}

pub struct ScalerEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScalerEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScalerEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_slot_name(&mut self, slot_name: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScalerEntry::VT_SLOT_NAME, slot_name);
  }
  #[inline]
  pub fn add_unk_3(&mut self, unk_3: u8) {
    self.fbb_.push_slot::<u8>(ScalerEntry::VT_UNK_3, unk_3, 0);
  }
  #[inline]
  pub fn add_unk_4(&mut self, unk_4: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScalerEntry::VT_UNK_4, unk_4);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScalerEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScalerEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScalerEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScalerEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScalerEntry");
      ds.field("name", &self.name());
      ds.field("slot_name", &self.slot_name());
      ds.field("unk_3", &self.unk_3());
      ds.field("unk_4", &self.unk_4());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ScalerEntryT {
  pub name: Option<String>,
  pub slot_name: Option<Vec<String>>,
  pub unk_3: u8,
  pub unk_4: Option<Vec<f32>>,
}
impl Default for ScalerEntryT {
  fn default() -> Self {
    Self {
      name: None,
      slot_name: None,
      unk_3: 0,
      unk_4: None,
    }
  }
}
impl ScalerEntryT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ScalerEntry<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let slot_name = self.slot_name.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let unk_3 = self.unk_3;
    let unk_4 = self.unk_4.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    ScalerEntry::create(_fbb, &ScalerEntryArgs{
      name,
      slot_name,
      unk_3,
      unk_4,
    })
  }
}
pub enum MeshEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MeshEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MeshEntry<'a> {
  type Inner = MeshEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MeshEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SLOT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MeshEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MeshEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<MeshEntry<'bldr>> {
    let mut builder = MeshEntryBuilder::new(_fbb);
    if let Some(x) = args.slot_name { builder.add_slot_name(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MeshEntryT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let slot_name = self.slot_name().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    MeshEntryT {
      name,
      slot_name,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MeshEntry::VT_NAME, None)}
  }
  #[inline]
  pub fn slot_name(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MeshEntry::VT_SLOT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for MeshEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("slot_name", Self::VT_SLOT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct MeshEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slot_name: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MeshEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    MeshEntryArgs {
      name: None,
      slot_name: None,
    }
  }
}

pub struct MeshEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MeshEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_slot_name(&mut self, slot_name: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MeshEntry::VT_SLOT_NAME, slot_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MeshEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MeshEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MeshEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MeshEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MeshEntry");
      ds.field("name", &self.name());
      ds.field("slot_name", &self.slot_name());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MeshEntryT {
  pub name: Option<String>,
  pub slot_name: Option<Vec<String>>,
}
impl Default for MeshEntryT {
  fn default() -> Self {
    Self {
      name: None,
      slot_name: None,
    }
  }
}
impl MeshEntryT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MeshEntry<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let slot_name = self.slot_name.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MeshEntry::create(_fbb, &MeshEntryArgs{
      name,
      slot_name,
    })
  }
}
pub enum TRBSMOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TRBSM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TRBSM<'a> {
  type Inner = TRBSM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TRBSM<'a> {
  pub const VT_BONES: flatbuffers::VOffsetT = 4;
  pub const VT_SCALERS: flatbuffers::VOffsetT = 6;
  pub const VT_MESH: flatbuffers::VOffsetT = 8;
  pub const VT_UNK: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TRBSM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TRBSMArgs<'args>
  ) -> flatbuffers::WIPOffset<TRBSM<'bldr>> {
    let mut builder = TRBSMBuilder::new(_fbb);
    if let Some(x) = args.unk { builder.add_unk(x); }
    if let Some(x) = args.mesh { builder.add_mesh(x); }
    if let Some(x) = args.scalers { builder.add_scalers(x); }
    if let Some(x) = args.bones { builder.add_bones(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TRBSMT {
    let bones = self.bones().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let scalers = self.scalers().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let mesh = self.mesh().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let unk = self.unk().map(|x| {
      Box::new(x.unpack())
    });
    TRBSMT {
      bones,
      scalers,
      mesh,
      unk,
    }
  }

  #[inline]
  pub fn bones(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoneEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoneEntry>>>>(TRBSM::VT_BONES, None)}
  }
  #[inline]
  pub fn scalers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScalerEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScalerEntry>>>>(TRBSM::VT_SCALERS, None)}
  }
  #[inline]
  pub fn mesh(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MeshEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MeshEntry>>>>(TRBSM::VT_MESH, None)}
  }
  #[inline]
  pub fn unk(&self) -> Option<UnkEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UnkEntry>>(TRBSM::VT_UNK, None)}
  }
}

impl flatbuffers::Verifiable for TRBSM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoneEntry>>>>("bones", Self::VT_BONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ScalerEntry>>>>("scalers", Self::VT_SCALERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MeshEntry>>>>("mesh", Self::VT_MESH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UnkEntry>>("unk", Self::VT_UNK, false)?
     .finish();
    Ok(())
  }
}
pub struct TRBSMArgs<'a> {
    pub bones: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoneEntry<'a>>>>>,
    pub scalers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScalerEntry<'a>>>>>,
    pub mesh: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MeshEntry<'a>>>>>,
    pub unk: Option<flatbuffers::WIPOffset<UnkEntry<'a>>>,
}
impl<'a> Default for TRBSMArgs<'a> {
  #[inline]
  fn default() -> Self {
    TRBSMArgs {
      bones: None,
      scalers: None,
      mesh: None,
      unk: None,
    }
  }
}

pub struct TRBSMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TRBSMBuilder<'a, 'b> {
  #[inline]
  pub fn add_bones(&mut self, bones: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoneEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRBSM::VT_BONES, bones);
  }
  #[inline]
  pub fn add_scalers(&mut self, scalers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ScalerEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRBSM::VT_SCALERS, scalers);
  }
  #[inline]
  pub fn add_mesh(&mut self, mesh: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MeshEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRBSM::VT_MESH, mesh);
  }
  #[inline]
  pub fn add_unk(&mut self, unk: flatbuffers::WIPOffset<UnkEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UnkEntry>>(TRBSM::VT_UNK, unk);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRBSMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TRBSMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TRBSM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TRBSM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TRBSM");
      ds.field("bones", &self.bones());
      ds.field("scalers", &self.scalers());
      ds.field("mesh", &self.mesh());
      ds.field("unk", &self.unk());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TRBSMT {
  pub bones: Option<Vec<BoneEntryT>>,
  pub scalers: Option<Vec<ScalerEntryT>>,
  pub mesh: Option<Vec<MeshEntryT>>,
  pub unk: Option<Box<UnkEntryT>>,
}
impl Default for TRBSMT {
  fn default() -> Self {
    Self {
      bones: None,
      scalers: None,
      mesh: None,
      unk: None,
    }
  }
}
impl TRBSMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TRBSM<'b>> {
    let bones = self.bones.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let scalers = self.scalers.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let mesh = self.mesh.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let unk = self.unk.as_ref().map(|x|{
      x.pack(_fbb)
    });
    TRBSM::create(_fbb, &TRBSMArgs{
      bones,
      scalers,
      mesh,
      unk,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TRBSM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trbsm_unchecked`.
pub fn root_as_trbsm(buf: &[u8]) -> Result<TRBSM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TRBSM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TRBSM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_trbsm_unchecked`.
pub fn size_prefixed_root_as_trbsm(buf: &[u8]) -> Result<TRBSM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TRBSM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TRBSM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trbsm_unchecked`.
pub fn root_as_trbsm_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRBSM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TRBSM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TRBSM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_trbsm_unchecked`.
pub fn size_prefixed_root_as_trbsm_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRBSM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TRBSM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TRBSM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TRBSM`.
pub unsafe fn root_as_trbsm_unchecked(buf: &[u8]) -> TRBSM {
  flatbuffers::root_unchecked::<TRBSM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TRBSM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TRBSM`.
pub unsafe fn size_prefixed_root_as_trbsm_unchecked(buf: &[u8]) -> TRBSM {
  flatbuffers::size_prefixed_root_unchecked::<TRBSM>(buf)
}
pub const TRBSM_EXTENSION: &str = "trbsm";

#[inline]
pub fn finish_trbsm_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<TRBSM<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_trbsm_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<TRBSM<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Model
}  // pub mod Titan

