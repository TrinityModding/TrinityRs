// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod titan {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod model {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        pub enum IndexesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Indexes<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Indexes<'a> {
            type Inner = Indexes<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Indexes<'a> {
            pub const VT_BUFFER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Indexes { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args IndexesArgs<'args>,
            ) -> flatbuffers::WIPOffset<Indexes<'bldr>> {
                let mut builder = IndexesBuilder::new(_fbb);
                if let Some(x) = args.buffer {
                    builder.add_buffer(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> IndexesT {
                let buffer = self.buffer().map(|x| x.into_iter().collect());
                IndexesT { buffer }
            }

            #[inline]
            pub fn buffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            Indexes::VT_BUFFER,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for Indexes<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "buffer",
                        Self::VT_BUFFER,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct IndexesArgs<'a> {
            pub buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for IndexesArgs<'a> {
            #[inline]
            fn default() -> Self {
                IndexesArgs { buffer: None }
            }
        }

        pub struct IndexesBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> IndexesBuilder<'a, 'b> {
            #[inline]
            pub fn add_buffer(
                &mut self,
                buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Indexes::VT_BUFFER, buffer);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndexesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                IndexesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Indexes<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Indexes<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Indexes");
                ds.field("buffer", &self.buffer());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct IndexesT {
            pub buffer: Option<Vec<u8>>,
        }
        impl Default for IndexesT {
            fn default() -> Self {
                Self { buffer: None }
            }
        }
        impl IndexesT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Indexes<'b>> {
                let buffer = self.buffer.as_ref().map(|x| _fbb.create_vector(x));
                Indexes::create(_fbb, &IndexesArgs { buffer })
            }
        }
        pub enum VerticesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Vertices<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Vertices<'a> {
            type Inner = Vertices<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Vertices<'a> {
            pub const VT_BUFFER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Vertices { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args VerticesArgs<'args>,
            ) -> flatbuffers::WIPOffset<Vertices<'bldr>> {
                let mut builder = VerticesBuilder::new(_fbb);
                if let Some(x) = args.buffer {
                    builder.add_buffer(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> VerticesT {
                let buffer = self.buffer().map(|x| x.into_iter().collect());
                VerticesT { buffer }
            }

            #[inline]
            pub fn buffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            Vertices::VT_BUFFER,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for Vertices<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "buffer",
                        Self::VT_BUFFER,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct VerticesArgs<'a> {
            pub buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for VerticesArgs<'a> {
            #[inline]
            fn default() -> Self {
                VerticesArgs { buffer: None }
            }
        }

        pub struct VerticesBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> VerticesBuilder<'a, 'b> {
            #[inline]
            pub fn add_buffer(
                &mut self,
                buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Vertices::VT_BUFFER, buffer);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> VerticesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                VerticesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Vertices<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Vertices<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Vertices");
                ds.field("buffer", &self.buffer());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct VerticesT {
            pub buffer: Option<Vec<u8>>,
        }
        impl Default for VerticesT {
            fn default() -> Self {
                Self { buffer: None }
            }
        }
        impl VerticesT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Vertices<'b>> {
                let buffer = self.buffer.as_ref().map(|x| _fbb.create_vector(x));
                Vertices::create(_fbb, &VerticesArgs { buffer })
            }
        }
        pub enum MorphBufferOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MorphBuffer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MorphBuffer<'a> {
            type Inner = MorphBuffer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MorphBuffer<'a> {
            pub const VT_BUFFER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MorphBuffer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MorphBufferArgs<'args>,
            ) -> flatbuffers::WIPOffset<MorphBuffer<'bldr>> {
                let mut builder = MorphBufferBuilder::new(_fbb);
                if let Some(x) = args.buffer {
                    builder.add_buffer(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> MorphBufferT {
                let buffer = self.buffer().map(|x| x.into_iter().collect());
                MorphBufferT { buffer }
            }

            #[inline]
            pub fn buffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            MorphBuffer::VT_BUFFER,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for MorphBuffer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "buffer",
                        Self::VT_BUFFER,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MorphBufferArgs<'a> {
            pub buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for MorphBufferArgs<'a> {
            #[inline]
            fn default() -> Self {
                MorphBufferArgs { buffer: None }
            }
        }

        pub struct MorphBufferBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MorphBufferBuilder<'a, 'b> {
            #[inline]
            pub fn add_buffer(
                &mut self,
                buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(MorphBuffer::VT_BUFFER, buffer);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MorphBufferBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MorphBufferBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MorphBuffer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MorphBuffer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MorphBuffer");
                ds.field("buffer", &self.buffer());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct MorphBufferT {
            pub buffer: Option<Vec<u8>>,
        }
        impl Default for MorphBufferT {
            fn default() -> Self {
                Self { buffer: None }
            }
        }
        impl MorphBufferT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MorphBuffer<'b>> {
                let buffer = self.buffer.as_ref().map(|x| _fbb.create_vector(x));
                MorphBuffer::create(_fbb, &MorphBufferArgs { buffer })
            }
        }
        pub enum MorphsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Morphs<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Morphs<'a> {
            type Inner = Morphs<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Morphs<'a> {
            pub const VT_MORPH_BUFFER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Morphs { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MorphsArgs<'args>,
            ) -> flatbuffers::WIPOffset<Morphs<'bldr>> {
                let mut builder = MorphsBuilder::new(_fbb);
                if let Some(x) = args.morph_buffer {
                    builder.add_morph_buffer(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> MorphsT {
                let morph_buffer = self
                    .morph_buffer()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                MorphsT { morph_buffer }
            }

            #[inline]
            pub fn morph_buffer(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphBuffer<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphBuffer>>,
                    >>(Morphs::VT_MORPH_BUFFER, None)
                }
            }
        }

        impl flatbuffers::Verifiable for Morphs<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MorphBuffer>>,
                    >>("morph_buffer", Self::VT_MORPH_BUFFER, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct MorphsArgs<'a> {
            pub morph_buffer: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MorphBuffer<'a>>>,
                >,
            >,
        }
        impl<'a> Default for MorphsArgs<'a> {
            #[inline]
            fn default() -> Self {
                MorphsArgs { morph_buffer: None }
            }
        }

        pub struct MorphsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MorphsBuilder<'a, 'b> {
            #[inline]
            pub fn add_morph_buffer(
                &mut self,
                morph_buffer: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MorphBuffer<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Morphs::VT_MORPH_BUFFER,
                    morph_buffer,
                );
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MorphsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MorphsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Morphs<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Morphs<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Morphs");
                ds.field("morph_buffer", &self.morph_buffer());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct MorphsT {
            pub morph_buffer: Option<Vec<MorphBufferT>>,
        }
        impl Default for MorphsT {
            fn default() -> Self {
                Self { morph_buffer: None }
            }
        }
        impl MorphsT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Morphs<'b>> {
                let morph_buffer = self.morph_buffer.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                Morphs::create(_fbb, &MorphsArgs { morph_buffer })
            }
        }
        pub enum BufferOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Buffer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Buffer<'a> {
            type Inner = Buffer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Buffer<'a> {
            pub const VT_INDEX_BUFFER: flatbuffers::VOffsetT = 4;
            pub const VT_VERTEX_BUFFER: flatbuffers::VOffsetT = 6;
            pub const VT_MORPHS: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Buffer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BufferArgs<'args>,
            ) -> flatbuffers::WIPOffset<Buffer<'bldr>> {
                let mut builder = BufferBuilder::new(_fbb);
                if let Some(x) = args.morphs {
                    builder.add_morphs(x);
                }
                if let Some(x) = args.vertex_buffer {
                    builder.add_vertex_buffer(x);
                }
                if let Some(x) = args.index_buffer {
                    builder.add_index_buffer(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> BufferT {
                let index_buffer = self
                    .index_buffer()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let vertex_buffer = self
                    .vertex_buffer()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let morphs = self
                    .morphs()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                BufferT {
                    index_buffer,
                    vertex_buffer,
                    morphs,
                }
            }

            #[inline]
            pub fn index_buffer(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Indexes<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Indexes>>,
                    >>(Buffer::VT_INDEX_BUFFER, None)
                }
            }
            #[inline]
            pub fn vertex_buffer(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vertices<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vertices>>,
                    >>(Buffer::VT_VERTEX_BUFFER, None)
                }
            }
            #[inline]
            pub fn morphs(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Morphs<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Morphs>>,
                    >>(Buffer::VT_MORPHS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for Buffer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Indexes>>,
                    >>("index_buffer", Self::VT_INDEX_BUFFER, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Vertices>>,
                    >>("vertex_buffer", Self::VT_VERTEX_BUFFER, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Morphs>>,
                    >>("morphs", Self::VT_MORPHS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BufferArgs<'a> {
            pub index_buffer: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Indexes<'a>>>,
                >,
            >,
            pub vertex_buffer: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Vertices<'a>>>,
                >,
            >,
            pub morphs: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Morphs<'a>>>,
                >,
            >,
        }
        impl<'a> Default for BufferArgs<'a> {
            #[inline]
            fn default() -> Self {
                BufferArgs {
                    index_buffer: None,
                    vertex_buffer: None,
                    morphs: None,
                }
            }
        }

        pub struct BufferBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BufferBuilder<'a, 'b> {
            #[inline]
            pub fn add_index_buffer(
                &mut self,
                index_buffer: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Indexes<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Buffer::VT_INDEX_BUFFER,
                    index_buffer,
                );
            }
            #[inline]
            pub fn add_vertex_buffer(
                &mut self,
                vertex_buffer: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Vertices<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Buffer::VT_VERTEX_BUFFER,
                    vertex_buffer,
                );
            }
            #[inline]
            pub fn add_morphs(
                &mut self,
                morphs: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Morphs<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Buffer::VT_MORPHS, morphs);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BufferBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BufferBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Buffer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Buffer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Buffer");
                ds.field("index_buffer", &self.index_buffer());
                ds.field("vertex_buffer", &self.vertex_buffer());
                ds.field("morphs", &self.morphs());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct BufferT {
            pub index_buffer: Option<Vec<IndexesT>>,
            pub vertex_buffer: Option<Vec<VerticesT>>,
            pub morphs: Option<Vec<MorphsT>>,
        }
        impl Default for BufferT {
            fn default() -> Self {
                Self {
                    index_buffer: None,
                    vertex_buffer: None,
                    morphs: None,
                }
            }
        }
        impl BufferT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Buffer<'b>> {
                let index_buffer = self.index_buffer.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let vertex_buffer = self.vertex_buffer.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let morphs = self.morphs.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                Buffer::create(
                    _fbb,
                    &BufferArgs {
                        index_buffer,
                        vertex_buffer,
                        morphs,
                    },
                )
            }
        }
        pub enum TRMBFOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TRMBF<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TRMBF<'a> {
            type Inner = TRMBF<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TRMBF<'a> {
            pub const VT_UNUSED: flatbuffers::VOffsetT = 4;
            pub const VT_BUFFERS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TRMBF { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TRMBFArgs<'args>,
            ) -> flatbuffers::WIPOffset<TRMBF<'bldr>> {
                let mut builder = TRMBFBuilder::new(_fbb);
                if let Some(x) = args.buffers {
                    builder.add_buffers(x);
                }
                builder.add_unused(args.unused);
                builder.finish()
            }

            pub fn unpack(&self) -> TRMBFT {
                let unused = self.unused();
                let buffers = self
                    .buffers()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                TRMBFT { unused, buffers }
            }

            #[inline]
            pub fn unused(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TRMBF::VT_UNUSED, Some(0)).unwrap() }
            }
            #[inline]
            pub fn buffers(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer>>,
                    >>(TRMBF::VT_BUFFERS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TRMBF<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("unused", Self::VT_UNUSED, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Buffer>>,
                    >>("buffers", Self::VT_BUFFERS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TRMBFArgs<'a> {
            pub unused: u32,
            pub buffers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>,
                >,
            >,
        }
        impl<'a> Default for TRMBFArgs<'a> {
            #[inline]
            fn default() -> Self {
                TRMBFArgs {
                    unused: 0,
                    buffers: None,
                }
            }
        }

        pub struct TRMBFBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TRMBFBuilder<'a, 'b> {
            #[inline]
            pub fn add_unused(&mut self, unused: u32) {
                self.fbb_.push_slot::<u32>(TRMBF::VT_UNUSED, unused, 0);
            }
            #[inline]
            pub fn add_buffers(
                &mut self,
                buffers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Buffer<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TRMBF::VT_BUFFERS, buffers);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TRMBFBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TRMBFBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TRMBF<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TRMBF<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TRMBF");
                ds.field("unused", &self.unused());
                ds.field("buffers", &self.buffers());
                ds.finish()
            }
        }
        #[non_exhaustive]
        #[derive(Debug, Clone, PartialEq)]
        pub struct TRMBFT {
            pub unused: u32,
            pub buffers: Option<Vec<BufferT>>,
        }
        impl Default for TRMBFT {
            fn default() -> Self {
                Self {
                    unused: 0,
                    buffers: None,
                }
            }
        }
        impl TRMBFT {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TRMBF<'b>> {
                let unused = self.unused;
                let buffers = self.buffers.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                TRMBF::create(_fbb, &TRMBFArgs { unused, buffers })
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TRMBF`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmbf_unchecked`.
        pub fn root_as_trmbf(buf: &[u8]) -> Result<TRMBF, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TRMBF>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TRMBF` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_trmbf_unchecked`.
        pub fn size_prefixed_root_as_trmbf(
            buf: &[u8],
        ) -> Result<TRMBF, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TRMBF>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TRMBF` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmbf_unchecked`.
        pub fn root_as_trmbf_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TRMBF<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TRMBF<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TRMBF` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_trmbf_unchecked`.
        pub fn size_prefixed_root_as_trmbf_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TRMBF<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TRMBF<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TRMBF and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TRMBF`.
        pub unsafe fn root_as_trmbf_unchecked(buf: &[u8]) -> TRMBF {
            flatbuffers::root_unchecked::<TRMBF>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TRMBF and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TRMBF`.
        pub unsafe fn size_prefixed_root_as_trmbf_unchecked(buf: &[u8]) -> TRMBF {
            flatbuffers::size_prefixed_root_unchecked::<TRMBF>(buf)
        }
        pub const TRMBF_EXTENSION: &str = "trmbf";

        #[inline]
        pub fn finish_trmbf_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TRMBF<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_trmbf_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<TRMBF<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Model
} // pub mod Titan
